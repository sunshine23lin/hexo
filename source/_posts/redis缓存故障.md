---
title: redis缓存故障
date: 2020-12-07 14:25:23
categories: Nosql
tags: 缓存
---

#  缓存穿透

**缓存穿透的概念,用户想查询一个数据，发现Redis没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多时候，缓存都没有命中，于是都去请求了持久层数据库。这个给持久层数据库造成很多的压力。**

![image-20201207150041108](https://jameslin23.gitee.io/2020/12/07/redis缓存故障/image-20201207150041108.png)

 **解决方法:**

**1、缓存空对象**

当存储层不命中时,即使返回空对象也将其缓存起来,设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源

![image-20201207150510313](https://jameslin23.gitee.io/2020/12/07/redis缓存故障/image-20201207150510313.png)

**但是这种方法会存在两个问题：**

>1、缓存区可能存在大量空值的键
>
>2、可能会存在缓存层和存储层会有一段时间空窗不一致，对保持一致性的业务会有影响

**2、布隆过滤器**

在查询缓存之间先在到布隆过滤器查询，没有则返回，有再走redis，DB查询操作

![image-20201207153906629](https://jameslin23.gitee.io/2020/12/07/redis缓存故障/image-20201207153906629.png)

**布隆过滤器原理**

本质上布隆过滤器是一个数据结构,比较巧妙的概率型数据结构,特点高效的插入和查询。

根据查询结果可以用来告诉你**某样东西一定不存在或者可能存在**。这句话是算法的核心。

相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的，同时布隆过滤器还有一个缺陷就是**数据只能插入不能删除。**

**数据如何存入布隆过滤器**

布隆过滤器是由一个很长的**bit数组**和一系列**哈希函数**组成的

数组的每个元素都只占1bit空间,并且每个元素只能0或者1

布隆过滤器还拥有k个哈希函数,当一个元素加入布隆过滤器时,会使用k个函数对其进行k次计算，得到k个哈希值，并且根据得到哈希值,在维数据对应下标的值置位1。

**判断某个数是否在布隆过滤器中，就对该元素进行k次哈希计算，得到的值在位数组中判断每个元素是否都为1，如果每个元素都为1，就说明这个值在布隆过滤器中。**

**布隆过滤器为什么会有误判**

当插入元素越来越多时,当一个不在布隆过滤器中的元素,经过同样规则哈希计算后，得到的值在位数据组中查询，有可能这些位置被其它元素先置为1了。

所以布隆过滤器存在误判的情况。

**但如果布隆过滤器判断某个元素不在布隆过滤器中，那么这个值就一定不在。**

**使用场景**

> - **网页爬虫对URL的去重**
> - **垃圾邮件过滤**
> - **解决数据库缓存击穿**
> - **秒杀系统**

#  缓存击穿

这里需要注意和缓存穿透的区别。缓存穿透，是指一个key非常热点,在不停的扛着大并发,大并发集中对这个点进行访问，当这个key在失效的瞬间,持续的大并发就穿破缓存,直接请求数据库，就像一个屏幕凿开一个洞。

当某个key在过期的瞬间,有大量的请求并发访问,这类数据一般是热点数据,由于缓存过期，会同时访问数据库来查询最新的数据，并回写缓存，会导致数据库压力过大。

**解决方法：**

**1、设置热点数据永不过期**

**2、加互斥锁**

分布式锁:使用分布式锁,保证了对每个Key只有一个线程去查询后端服务,其它线程没有获得分布式锁的权限，因此只需要等待即可。

#  缓存雪崩

缓存雪崩,是指在某一个时间段,缓存集中过期失效（或者redis宕机）。

比如马上就双12零点,很快就会有一波抢购，这波抢购商品比较集中的放在redis，假设缓存一个小时，那么到凌晨一点钟，这批缓存就都过期了，而对这批商品的访问查询,都落在数据库上，对于数据库而言，都会产生周期性的压力波峰。于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层也回掉的情况

**解决方案：**

**1、redis高可用**

这个思想的含义是，既然 redis 有可能挂掉，那我多增设几台 redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。

**2、限流降级**

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。

**3、数据预热**

数据预热的含义是在正式部署之前，把可能的数据线预先访问一遍，这样部分可能大量访问的数据就会加载到缓存。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀