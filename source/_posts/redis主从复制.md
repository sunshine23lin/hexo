---
title: redis主从复制
date: 2020-12-05 10:24:07
categories: Nosql
tags: 缓存
---

#  概念

**主从复制,是指将一台Redis服务器的数据,复制到其它的Redis服务器。前称为主节点(master),后者称为从节点(slave);数据的复制是当向的。只能由主节点到从节点。Master负责写，Slave以读为主。**

**主从复制的作用主要包括:**

- 数据冗余: 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方法
- 故障恢复: 当节点出现问题时,可以由从节点提供服务器,实现快速故障恢复
- 负载均衡: 在主从复制的基础上,配合读写分离,可以由节点提供些服务,由从节点提供读服务(即写redis数据时应用连接主节点，读Redis数据时应用连接从节点),分担服务器负载；尤其是在写少读多的场景，通过多个节点分担读负载,可以大大提高Redis服务的并发量

**缺点**

- 当主节点宕机时,需要自己手动恢复，当恢复不及时会造成线上故障

#  旧版复制原理

**Redis的复制功能分为同步(sync) 和命令传播(command propagete)两个状态:**

- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
- 命令传播操作则用于主服务器的数据库状态被修改,导致主从服务器的数据库状态出现不一致时，让主从服务器状态重新回到一致状态。

##  同步操作

从服务对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成,以下是SYNC命令的执行步骤:

> 1) 从服务器向主服务器发送SYNC命令
>
> 2) 收到SYNC命令的主服务器执行BGSAVE命令,在后台生成一个RDB文件,并使用一个缓冲区记录从现在开始执行的所有写命令。
>
> 3) 当主服务器BGSAVE执行完毕，主服务器会将从BGSAVE生成RDB文件发送给从服务器，从服务器接收并载入这个RDB文件,将自己的数据库更新至主服务器执行BGSAVE命令时的数据库状态。
>
> 4) 主服务器将记录在缓冲区里面的所有命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

![image-20201205110020380](https://jameslin23.gitee.io/2020/12/05/redis主从复制/image-20201205110020380.png)

**同步过程**

![image-20201205180035866](https://jameslin23.gitee.io/2020/12/05/redis主从复制/image-20201205180035866.png)

##  命令传播

在同步操作执行完毕之后,主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。

**举个例子**

假设一个主服务器和一个从服务器刚刚完成同步操作，他们的数据库都保存了相同的5个键k1至k5,如果这时候，客户端向主服务器发送命令DEL K3,那么主服务器在执行完成这个DEL K3之后，主从服务器状态出现不一致。

![image-20201205113817827](https://jameslin23.gitee.io/2020/12/05/redis主从复制/image-20201205113817827.png)

**为了让主从服务器再次回到一致状态，主服务器需要对服务器执行命令传播操作，主服务器会将自己执行命令操作发送给从服务器，让主从服务器再次回到一致。**

![image-20201205114120580](https://jameslin23.gitee.io/2020/12/05/redis主从复制/image-20201205114120580.png)

##  旧版复制缺陷

在redis中,从服务器对主服务器复制可以分以下2种情况

**初次复制：** 从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上次复制的主服务器不同。

**断线后重新复制：** 处于命令传播阶段的主从服务器因为网络原因中断复制，但从服务器通过自动重连重新连上主服务器，并继续复制服务器。

**但对于旧版初次复制，能够很好的完成任务，但对于断线后复制来说，旧版本复制让主从服务器重新回到一致状态，效率很低。**

![image-20201205180010434](https://jameslin23.gitee.io/2020/12/05/redis主从复制/image-20201205180010434.png)

**断开期间，主从增加3个命令（现实实际不止），从服务器发送SYNC,却从K1-K5生成RDB，实际K1,K2是没必要，如果命令多，这部分造成很大资源浪费，效率低下。Redis2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步同步操作。**

#  新版复制原理

##  PSYNC命令

**PSYNC命令具有完整同步和部分重同步**

- **其中完整重同步用于处理初次复制情况**:完整同步的执行步骤和SYNC命令的执行步骤基本一样，他们都是通过主服务器创建并发送RDB文件,以及向从服务器发送保存的缓冲区里面的写命令进行同步。
- **而部分同步则用于处理断线后重复情况**:当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处状态。

##  部分同步的实现

部分同步功能由以下部分构成:

- **主服务器的复制偏移量和从服务器的复制偏移量**
- **主服务器的复制积压缓冲区**
- **服务器的运行ID**

###  复制偏移量

执行复制双方------主服务器和从服务器会分别维护一个复制偏移量

- **主服务器每次向从服务器传播N个字节的数据，就将自己的复制偏移量的值加上N**
- **从服务器每次收到主服务器传播来N个字节的数据时，就将自己复制偏移量的值加上N**

通过对比主从服务器的复制偏移量,程序可以很容易地知道主从服务器是否处于一致状态:

- 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同
- 相反,如果主从服务器两者的偏移量并不相同,那么说明状态不一致。

###  复制积压缓冲区

**复制积压缓冲区是由主从服务器维护的一个固定长度先进先出队列,默认大小为1MB**

当主服务器进行命令传播时,他不仅会将命令发送给所有从服务器,还会将写命令入队列到复制积压缓冲区里面。

![image-20201205142401789](https://jameslin23.gitee.io/2020/12/05/redis主从复制/image-20201205142401789.png)

因此,主服务器的复制积压缓冲区里面会保存着一份最近传播的写命令,并且复制积压缓冲区会为队列中每个字节记录相应的复制偏移量

![image-20201205142551707](https://jameslin23.gitee.io/2020/12/05/redis主从复制//image-20201205142551707.png)

**过程**

- 当服务器断线之后,它立即重新连接主服务器,并向主服务器发送PSYNC命令,报告自己的复制偏移量10086。

- 当服务器收到从服务器发来PSYNC命令以及偏移量10086之后的数据是否在于复制积压缓冲区里面,结果发现这些数据依然存在，

  于是主服务器向从服务器发送+CONTINUE回复，表示数据同步以部分同步模式。

- 接着主服务器会将复制积压缓冲区10086偏移之后所有数据都发给从服务器

- 从服务器只要接收这33字节缺失数据,就可以回到主服务器一致状态。

###  服务器运行ID

除了复制偏移量和复制积压缓冲区之外,实现部分同步还需要用到服务器运行状态ID

- **每个redis服务器,不论主服务器还是从服务器,都会有自己的运行ID**
- **运行ID在服务器启动时自动生成,由40个随机的16进制字符组成**

当从服务器对主服务器进行初次复制,主服务器会将自己的运行ID传给从服务器,而从服务器则会将这个运行ID保存起来。

当从服务器断线并且重新连上一个主服务器时，从服务器将像当前连接主服务器发送之前保存的运行ID

- **如果从服务器保存的运行ID和当前连接的主服务器运行ID相同，主服务器可以尝试执行部分同步。**
- **相反，ID不相同，则对从服务器执行完全同步。**

#  Redis安装

##  单机版安装

1. **下载安装包**

   > wget http://download.redis.io/releases/redis-5.0.7.tar.gz 

2. **解压**

   >  tar  -xvf  redis-5.0.7.tar.gz

3. **编译**

   > (1) cd redis-5.0.7/
   >
   > (2) make
   >
   > (3) cd src/
   >
   > (4) make instal

4. **整理配置文件和启动文件**

   > (1) mkdir conf
   >
   > (2) mkdir bin
   >
   > (3) 将redis.conf 和sentinel.conf 放入conf
   >
   > (4) 进入src目录,将mkreleasehdr.sh、redis-benchmark、redis-check-aof、redis-check-rdb、redis-cli、redis-server、redis-sentinel文件复制到 bin 文件夹
   >
   > (5) cp mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server redis-sentinel ../bin/

5. **启动**

   >  ./redis-server ../conf/redis.conf 

## 主从配置

**首先看一下redis.conf 配置文件中的各个参数，详解如下**

~~~properties
# redis进程是否以守护进程的方式运行，yes为是，no为否(不以守护进程的方式运行会占用一个终端)。 
daemonize no 
# 指定redis进程的PID文件存放位置 
pidfile /var/run/redis.pid 
# redis进程的端口号 
port 6379 
#是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码和bind，可以开启。否则最好关闭设置为no。 
protected-mode yes 
# 绑定的主机地址 
bind 127.0.0.1 
# 客户端闲置多长时间后关闭连接，默认此参数为0即关闭此功能 
timeout 300 
# redis日志级别，可用的级别有debug.verbose.notice.warning 
loglevel verbose 
# log文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为stdout的话，就会将日志信息输出到/dev/null里面去了 
logfile stdout 
# 设置数据库的数量，默认为0可以使用select <dbid>命令在连接上指定数据库id 
databases 16 
# 指定在多少时间内刷新次数达到多少的时候会将数据同步到数据文件 
save <seconds> <changes> 
# 指定存储至本地数据库时是否压缩文件，默认为yes即启用存储 
rdbcompression yes 
# 指定本地数据库文件名 
dbfilename dump.db 
# 指定本地数据问就按存放位置 
dir ./ 
# 指定当本机为slave服务时，设置master服务的IP地址及端口，在redis启动的时候他会自动跟master进行数据同步 
replicaof <masterip> <masterport> 
# 当master设置了密码保护时，slave服务连接master的密码 
masterauth <master-password> 
# 设置redis连接密码，如果配置了连接密码，客户端在连接redis是需要通过AUTH<password>命令提供密码，默认关闭 
requirepass footbared 
# 设置同一时间最大客户连接数，默认无限制。redis可以同时连接的客户端数为redis程序可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回 max number of clients reached 错误信息 
maxclients 128 
# 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key。当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 
maxmemory<bytes> 
# 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no。 
appendonly no 
# 指定跟新日志文件名默认为appendonly.aof 
appendfilename appendonly.aof 
# 指定更新日志的条件，有三个可选参数 - no：表示等操作系统进行数据缓存同步到磁盘(快)，always：表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)， everysec：表示每秒同步一次(折衷，默认值)； 
appendfsync everysec 
~~~

**主机配置(192.168.10.8)**

~~~properties
# Redis 默认只允许本机访问，把 bind 修改为 0.0.0.0 表示允许所有远程访问。如果想指定限制访问，可设置对应的 ip。
bind 0.0.0.0 
# 端口
port 6379 
# 关闭保护模式，可以外部访问。
protected-mode：no 
# 后台启动
daemonize yes
# 日志文件
logfile ./redis.log 
#  设置 redis 连接密码。
requirepass 123456
# slave 服务连接 master 的密码。。
masterauth 123456 
~~~

**从机配置(192.168.10.10)**

~~~properties
# Redis 默认只允许本机访问，把 bind 修改为 0.0.0.0 表示允许所有远程访问。如果想指定限制访问，可设置对应的 ip。
bind 0.0.0.0 
# 端口
port 6379 
# 关闭保护模式，可以外部访问。
protected-mode：no 
# 后台启动
daemonize yes
# 日志文件
logfile ./redis.log 
#  设置 redis 连接密码。
requirepass 123456
# slave 服务连接 master 的密码。。
masterauth 123456 
# 配置主机地址
replicaof 192.168.10.8 6379
~~~

**从机配置:(192.168.10.3)**

```properties
# Redis 默认只允许本机访问，把 bind 修改为 0.0.0.0 表示允许所有远程访问。如果想指定限制访问，可设置对应的 ip。
bind 0.0.0.0 
# 端口
port 6379 
# 关闭保护模式，可以外部访问。
protected-mode：no 
# 后台启动
daemonize yes
# 日志文件
logfile ./redis.log 
#  设置 redis 连接密码。
requirepass 123456
# slave 服务连接 master 的密码。。
masterauth 123456 
# 配置主机地址 
replicaof 192.168.10.8 6379    
```

#  小总结

- **Redis2.8之前的复制功能不能高效地处理断线后重复复制情况,但Redis2.8新添的部分功能重同步功能可以解决这个问题**
- **部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分来实现**
- **在复制操作刚开始时候，从服务器会成为主服务器客户端，并通过向主服务器发送命令请求执行复制步骤,而在复制操作后期。主从复制会互相成为对方的客户端。**
- **主服务器通过从服务器传播命令来更新服务器状态，保存主从一致,而从服务器则通过向主服务器发送命令来进行心跳检测,以及命令丢失检测。**
- **单机版和主从配置部署**