---
title: RocketMQ拉取策略
date: 2020-12-04 19:28:57
categories: 消息队列
tags: MQ
---

#  消费者拉取策略（Master-Slave）

#  ConsumeQueue文件也是基于os cache的

> ConsumeQueue会被大量的消费者发送的请求高并发读取，所以ComsumeQueue文件读取操作非常频繁，而且同时会极大影响到消费者进行拉取的性能和消费吞吐量
>
> 对于Broker机器的磁盘上的大量的comsumeQueue文件，在写入的时候也都是优先进os cache中，ConsumeQueue文件主要存放消息CommitLog消息offest,所以每个文件很小,30万条消息的offset就只有5.72MB，他们整体数据量小,几乎可以完全被os缓存在内存cache里面。
>
> 实际上在消费者拉取消息的时候，第一步大量的频繁读取ConsumeQueue文件,几乎可以说是跟读内存里的数据的性能是一样的，通过这个可以保证数据消费的高性能以及高吞吐量。

##  读取CommitLog基于cache+磁盘一起读的

> 当你拉取消息时候，可以轻松从os cache里读取少量的ConsumeQueue文件offest,这个性能极高，但是当去CommitLog文件读取完整消息数据时候，会有两种可能

**第一种**

> 如果你读取的是那种刚刚写入CommitLog的数据，那么大概率他们还停留在os cache中，此时你可以顺利的直接从os cache里面读取CommitLog中的数据，这个是内存读取，性能很高。

**第二种**

> 你也许读取的是比较早之前写入CommitLog的数据，那些数据早就被刷入磁盘了，已经不在os cache里了，那么此时你
> 就只能从磁盘上的文件里读取了，这个性能是比较差一些的。

**什么时候会从os cache读？什么时候会从磁盘读？**

> 其实这个问题很简单了，如果你的消费者机器一直快速的在拉取和消费处理，紧紧的跟上了生产者写入broker的消息速率，那么你每次拉取几乎都是在拉取最近人家刚写入CommitLog的数据，那几乎都在os cache里。
>
> 但是如果broker的负载很高，导致你拉取消息的速度很慢，或者是你自己的消费者机器拉取到一批消息之后处理的时候性能很低，处理的速度很慢，这都会导致你跟不上生产者写入的速率。
>
> 比如人家都写入10万条数据了，结果你才拉取了2万条数据，此时有5万条最新的数据是在os cache里，有3万条你还没拉取的数据是在磁盘里，那么当后续你再拉取的时候，必然很大概率是从磁盘里读取早就刷入磁盘的3万条数据。

##  Master Broker什么时候会让你从Slave Broker拉取数据？

> 假设此时你的broker里已经写入了10万条数据，但是你仅仅拉取了2万条数据，
>
> 下次你拉取的时候，是从第2万零1条数据开始继续往后拉取的，是不是？
>
> 也就是说，此时你有8万条数据是没有拉取的！
>
> 然后broker自己是知道机器上当前的整体物理内存有多大的，而且他也知道自己可用的最大空间占里面的比例，他是知道自己的消息最多可以在内存里放多少的！比如他心知肚明，他最多也就在内存里放5万条消息而已！
>
> 因为他知道，他最多只能利用10GB的os cache去放消息，这么多内存最多也就放5万左右的消息。
>
> 然后这个时候你过来拉取消息，他发现你还有8万条消息没有拉取，这个8万条消息他发现是大于10GB内存最多存放的5万条消息的，那么此时就说明，肯定有3万条消息目前是在磁盘上的，不在os cache内存里！
>
> 所以他经过上述判断，会发现此时你很大概率会从磁盘里加载3万条消息出来！他会认为，出现这种情况，很可能是因为自己作为
> master broker负载太高了，导致没法及时的把消息给你，所以你落后的进度比较多。
>
> 这个时候，他就会告诉你，我这次给你从磁盘里读取3万条消息，但是下次你还是从slave broker去拉取吧！

#  基于mmap内存映射实现磁盘文件的高性能读写

##  传统IO拷贝

![image-20201203104024287](https://jameslin23.gitee.io/2020/12/01/RocketMQ/image-20201203104024287.png)

**读跟写的过程都发生2次拷贝**

##   mmap技术

> mmap内存映射，把物理上磁盘文件的一些地址和用户进程私有空间的一些虚拟内存进行一个映射
>
> 内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间<---->用户空间两者之间需要大量数据传输等操作的话效率是非常高的。
>
> 基于JDK NIO包下的MappedByteBuffer的map()函数，先将一个磁盘文件(比如一个CommitLog文件或者一个ComsumeQueue文件)映射到内存中

![image-20201203104910237](https://jameslin23.gitee.io/2020/12/01/RocketMQ/image-20201203104910237.png)

**mmap技术在进行文件映射的时候，一般有大小限制，在1G~2GB之间**

**所以RocketMQ才能让CommitLog单个文件在1GB,ConsumeQueue在5.72MB，不会太大**

##  基于mmap技术+pagecache技术实现高性能的文件读写

###  写过程

> 比如写入消息到CommitLog文件，你先把一个CommitLog文件通过MappedByteBuffer的map()函数映射其它地址到你的虚拟内存地址,接着就可以对这个MappedByteBuffer执行写入操作了，写入时候他会直接进入PageCache中，然后过一段时间之后,由os的线程异步刷入磁盘中

![image-20201203110819924](https://jameslin23.gitee.io/2020/12/01/RocketMQ/image-20201203110819924.png)

**只有一次数据拷贝**

###  读过程

> 先判断读取的数据是否在PageCache里，如果在就直接从PageCache读取，如果不在，就会从磁盘文件加载到PageCache中去。而PageCache技术在加载数据时候，还会将你加载数据块的临近的其它数据块也一起加载到PageCache里

![image-20201204090234982](https://jameslin23.gitee.io/2020/12/01/RocketMQ/image-20201204090234982.png)

## 预映射机制 + 文件预热机制

**(1)内存预映射机制**：Broker会针对磁盘上的各种CommitLog、ConsumeQueue文件预先分配好MappedFile，也就是提前对一些
可能接下来要读写的磁盘文件，提前使用MappedByteBuffer执行map()函数完成映射，这样后续读写文件的时候，就可以直接执行
了。

**(2)文件预热：**在提前对一些文件完成映射之后，因为映射不会直接将数据加载到内存里来，那么后续在读取尤其是CommitLog、
ConsumeQueue的时候，其实有可能会频繁的从磁盘里加载数据到内存中去。