<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JAVA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jameslin23.gitee.io/"/>
  <updated>2021-01-09T12:10:11.622Z</updated>
  <id>https://jameslin23.gitee.io/</id>
  
  <author>
    <name>LeBron Tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法之直接插入排序</title>
    <link href="https://jameslin23.gitee.io/2021/01/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://jameslin23.gitee.io/2021/01/09/排序算法之直接插入排序/</id>
    <published>2021-01-09T11:54:50.000Z</published>
    <updated>2021-01-09T12:10:11.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直接插入排序的规律"><a href="#直接插入排序的规律" class="headerlink" title="直接插入排序的规律"></a>直接插入排序的规律</h2><p>每一步将一个待排序的记录，插入到前面已经排好序的有序序列中，直到插完位置</p><img src="https://jameslin23.gitee.io/2020/01/09/排序算法之直接插入排序/image-20210109195852331.png" alt="image-20210109195852331" style="zoom:80%;"><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>时间复杂度：平均时间O(N^2)  最差时间O(N^2) 相对稳定</strong></p><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><ol><li>定义第一个for循环，从下标1开始，逐个进行排序</li><li>定义一个当前变量tmep[i]</li><li>定义第二个for循环，从已排好序的序列中进行查找</li><li>找到合适条件插入位置上</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">             <span class="keyword">int</span> cur = arr[i];</span><br><span class="line">             <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;-<span class="number">1</span>;j--)&#123;</span><br><span class="line">                 <span class="comment">// 继续往前查找</span></span><br><span class="line">                 <span class="keyword">if</span> (cur&lt;arr[j])&#123;</span><br><span class="line">                     <span class="comment">// [j+1]此时就是cur</span></span><br><span class="line">                     arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 找到适合的位置</span></span><br><span class="line">                     arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">                     flag = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 一直找不到说明是最小的值</span></span><br><span class="line">             <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                 arr[<span class="number">0</span>] = cur;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;直接插入排序的规律&quot;&gt;&lt;a href=&quot;#直接插入排序的规律&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序的规律&quot;&gt;&lt;/a&gt;直接插入排序的规律&lt;/h2&gt;&lt;p&gt;每一步将一个待排序的记录，插入到前面已经排好序的有序序列中，直到插完位置&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jameslin23.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://jameslin23.gitee.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之选择排序</title>
    <link href="https://jameslin23.gitee.io/2021/01/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://jameslin23.gitee.io/2021/01/09/排序算法之选择排序/</id>
    <published>2021-01-09T11:30:46.000Z</published>
    <updated>2021-01-09T12:09:36.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序规律"><a href="#选择排序规律" class="headerlink" title="选择排序规律"></a>选择排序规律</h2><ol><li><p>从待排序中，找到关键字最小的元素</p></li><li><p>如果最小元素不是待排序列中的第一个元素，将其和第一个元素互换</p></li><li><p>从余下N-1个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束</p><img src="https://jameslin23.gitee.io/2020/01/09/排序算法之选择排序/image-20210109193647382.png" alt="image-20210109193647382" style="zoom:50%;"></li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>时间复杂度：平均时间O(N^2)  最差时间O(N^2) 相对稳定</strong></p><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><ol><li>定义2个for循环，第一个for循环是需要比较的轮数，第二for循环找出最小的数并进行交换</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (min&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                   min = arr[j+<span class="number">1</span>];</span><br><span class="line">                   arr[j+<span class="number">1</span>] = arr[i];</span><br><span class="line">                   arr[i] = min;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择排序规律&quot;&gt;&lt;a href=&quot;#选择排序规律&quot; class=&quot;headerlink&quot; title=&quot;选择排序规律&quot;&gt;&lt;/a&gt;选择排序规律&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从待排序中，找到关键字最小的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果最小元素不是待排序
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jameslin23.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://jameslin23.gitee.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之冒泡排序</title>
    <link href="https://jameslin23.gitee.io/2021/01/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://jameslin23.gitee.io/2021/01/09/排序算法之冒泡排序/</id>
    <published>2021-01-09T10:58:41.000Z</published>
    <updated>2021-01-09T12:09:07.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡算法规律"><a href="#冒泡算法规律" class="headerlink" title="冒泡算法规律"></a>冒泡算法规律</h2><ol><li>比较相邻的元素，如果第一个比第二个大，就交换。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这步做完，最后元素会是最大的数（第一波冒泡完成）</li><li>针对所有的元素以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><img src="https://jameslin23.gitee.io/2020/01/09/排序算法之冒泡排序/image-20210109191047874.png" alt="image-20210109191047874" style="zoom: 67%;"><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>时间复杂度：平均时间O(N^2)  最差时间O(N^2) 相对稳定</strong></p><h2 id="编码思路"><a href="#编码思路" class="headerlink" title="编码思路"></a>编码思路</h2><ol><li>两个for循环，第一个for循环冒泡轮数，第二个for循环进行换位判断。</li><li>定义变量temp</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> [] bubbleSort(<span class="keyword">int</span> [] arr)&#123;</span><br><span class="line">    <span class="comment">// 需要比较的轮数 i</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">         <span class="comment">// i-1对比的数量会依次递减</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                  arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                  arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化代码</strong></p><p>当你这轮的数字都没有进行交换时，说明数字已经是顺序了，可以退出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化</span></span><br><span class="line"> <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> [] bubbleSort2(<span class="keyword">int</span> [] arr)&#123;</span><br><span class="line">     <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 调出循环标识</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">         <span class="comment">// i-1对比的数量会依次递减</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                 <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                 arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                 arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                 flag = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             flag = <span class="keyword">false</span>; <span class="comment">// 重置 flag!!!, 进行下次判断</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡算法规律&quot;&gt;&lt;a href=&quot;#冒泡算法规律&quot; class=&quot;headerlink&quot; title=&quot;冒泡算法规律&quot;&gt;&lt;/a&gt;冒泡算法规律&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;比较相邻的元素，如果第一个比第二个大，就交换。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素做同样的工作，
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jameslin23.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://jameslin23.gitee.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://jameslin23.gitee.io/2021/01/03/ThreadLocal/"/>
    <id>https://jameslin23.gitee.io/2021/01/03/ThreadLocal/</id>
    <published>2021-01-03T05:37:43.000Z</published>
    <updated>2021-01-09T10:45:10.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是一个本地线程副本变量<strong>工具类</strong>。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用。适用于各个线程不共享变量值的操作。</p><h2 id="ThreadLocal-工作原理"><a href="#ThreadLocal-工作原理" class="headerlink" title="ThreadLocal 工作原理"></a>ThreadLocal 工作原理</h2><p>每个线程的内部维护一个ThreadLocalMap，它是一个Map(key,value)数据格式，key是一个弱引用。也就是ThreadLocal本身,而value存在是线程变量的值。</p><p>也就是说ThreadLocal本身并不存储线程的变量值，<strong>它只是一个工具类，用来维护线程内部的Map,帮助存和取变量。</strong></p><img src="https://jameslin23.gitee.io/2021/01/03/ThreadLocal/image-20210103140842502.png" alt="image-20210103140842502" style="zoom: 67%;"><h2 id="ThreadLocal解决Hash冲突"><a href="#ThreadLocal解决Hash冲突" class="headerlink" title="ThreadLocal解决Hash冲突"></a>ThreadLocal解决Hash冲突</h2><p>与HashMap不同，ThreadLocalMap结构非常简单，没有next引用,也就是ThreadLocalMap中解决Hash冲突的方式并非链表的方法，而是采用线性探测方法。所谓线性探测，就是根据key的hashcode值确定元素在table数组中的位置，如果发现这个位置已经被其它key值占用，则利用固定算法寻找一定步长的下一个位置，依次判断，直至找到能够存放的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"> * Increment i modulo len.</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line"> * Decrement i modulo len.</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候Entry中key已经被回收，但是value又是强引用不会被垃圾收集器回收。这样ThreadLocal的线程如果一直执行运行，value就一直得不到回收，这样就会发生内存泄漏。</p><p>ThreadLocalMap的key是弱引用</p><p>ThreadLocalMap中key是弱引用，而value是强引用才会导致内存泄漏的问题，至于为什么要这样设计，这样分2种情况来讨论：</p><ul><li>key使用强引用：这样会导致一个问题,引用的ThreadLocal对象被回收了，但是ThreadLocalMap还有持有ThreadLocal强引用，如果没有手动删除，ThreadLocal不会被回收，则会导致内存泄漏。</li><li>key使用弱引用：这样的话，引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。</li></ul><p>比较以上两种情况，我可以发现：由于ThreadLocalMap的生命周期跟Thread一样，如果都没有手动删除对应key,会导致内存 泄漏，但是使用弱引用可以多一层保障。</p><h2 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h2><p>ThreadLocal适用于独立变量副本的情况，比如Hibernate的session获取场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session =  threadLocal.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(session ==<span class="keyword">null</span>&amp;&amp;!session.isOpen())&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(session);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h2&gt;&lt;p&gt;ThreadLocal是一个本地线程副本变量&lt;strong&gt;工具类&lt;
      
    
    </summary>
    
      <category term="并发编程" scheme="https://jameslin23.gitee.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://jameslin23.gitee.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之垃圾回收器G1</title>
    <link href="https://jameslin23.gitee.io/2020/12/31/JVM%E7%AF%87%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8G1/"/>
    <id>https://jameslin23.gitee.io/2020/12/31/JVM篇之垃圾回收器G1/</id>
    <published>2020-12-31T02:10:36.000Z</published>
    <updated>2021-01-09T10:43:48.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性质。</p><p>在JDK1.7版本正式启动，移除了Experimental的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel组合，被Oracle官方称为“全功能垃圾收集器”。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>分代收集</p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。从堆的结构上看，他不要求整个Eden区，Old区都是固定的，也不再坚持固定大小和固定数量。</li><li>将堆空间划分若干个区域，这些区域中包括了逻辑上年轻代和老年代。</li></ul><p>空间整合</p><ul><li>G1将内存划分为一个个的region，内存回收以region作为基本单位。Region之间是复制算法，但整体上实际可以看做标记-压缩算法。两种算法都可以避免内存碎片化。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其当Java堆非常大时候，G1优势更加明显。</li></ul><p>可预测模型</p><p>G1除了追求低停顿外，还能建立可预测模型的停顿时间，能让使用者明确规定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范畴，因此在全局停顿的情况下也能较好的控制</li><li>G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小和回收所需时间经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。保证了G1收集器在有限时间内可以获得尽可能高的收集效率。</li></ul><h2 id="分区Region"><a href="#分区Region" class="headerlink" title="分区Region"></a>分区Region</h2><p>使用G1收集器，它将整个java堆划分约2048个大小相同独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB、2MB、4MB、8MB、16MB、32MB。可以通过-XX:C1HeapRegionSize设定，所有的Region大小相同，且在JVM生命周期内不会被改变。</p><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器G1/image-20201231110613736.png" alt="image-20201231110613736" style="zoom: 67%;"><ul><li>一个region有可能属于Eden,Survivor或者Old内存区域。但一个region只能属于一个角色。</li><li>G1还增加一个新的内存区域，叫做Humongous内存区域，主要存储大对象。</li></ul><p>设置H的原因</p><blockquote><p>对于堆中的大对象，默认直接分配到老年代，但是如果它是一个短期存在的大对象，就会占用老年代内存。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续H区来存储。</p></blockquote><h2 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h2><p>G1垃圾回收主要包括以下3个环节</p><ul><li>年轻代GC</li><li>老年代并发标记过程</li><li>混合回收</li><li>失败保护机制（Full GC）</li></ul><p><strong>总体概况</strong></p><p>当年轻代的Eden区用尽时开始年轻代回收；G1暂停所有应用程序线程，启动多线程执行年轻代回收。年轻代区间存活对象移动到survivor区或者old；当堆内存使用达到一定值（默认45）时，开始老年代并发标记过程。标记完成马上开始混合回收过程。对于一个混合回收期，G1从老年代移动存活对象到空闲区，G1老年代回收不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的region即可。</p><p><strong>Remembered Set</strong></p><p>存在一个Region中的对象被其它任意Region对象引用，避免扫描整个java堆。</p><p>每个Region都有一个对应Remembered Set;记录其它对象对自己的引用。</p><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器G1/image-20201231114119798.png" alt="image-20201231114119798" style="zoom: 50%;"><h2 id="常用的设置"><a href="#常用的设置" class="headerlink" title="常用的设置"></a>常用的设置</h2><ul><li><strong>-XX:+UseG1GC</strong> 手动指定使用G1收集器执行内存回收任务</li><li><strong>-XX:G1HeapRegionSize</strong> 设置Region的大小，值是2的幂，范围是1MB到32MB之间，目标是根据最小堆可以划分约2048个区域，默认是堆内存的1/2000。</li><li><strong>-XX:MaxGCPauseMillis</strong> 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不能保证成功），默认值200ms</li><li><strong>-XX:ParallelGCThead</strong> 设置STW工作线程数的值，最多设置为8</li><li><strong>-XX:ConcGCThreads</strong> 设置并发标记的线程数</li><li><strong>-XX:InitiatingHeapOccupancyPercent</strong> 设置触发并发GC周期的Java堆占用率阈值，超过此值，就触发GC。默认值是45。</li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li>开启G1垃圾收集器</li><li>设置堆最大内存</li><li>设置停顿时间</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>面向服务端应用，针对具有大内存、多处理器的机器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收器" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之垃圾回收器CMS</title>
    <link href="https://jameslin23.gitee.io/2020/12/31/JVM%E7%AF%87%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8CMS/"/>
    <id>https://jameslin23.gitee.io/2020/12/31/JVM篇之垃圾回收器CMS/</id>
    <published>2020-12-31T00:31:20.000Z</published>
    <updated>2021-01-09T10:43:15.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>在JDK 1.5时期，HotSpot推出一款在强交互应用中几乎认为有划时代意义的垃圾收集器：CMS(Concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，他第一次实现了让垃圾收集线程与用户线程同时工作，</li><li>CMS的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互程序，良好的响应速度能提高用户体验。</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>CMS整个过程比之前收集器要复杂，整个过程分4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p><ul><li>初始标记阶段：在这个阶段中，程序所有的工作线程都将会因为STW机制而出现短暂的暂停。这个阶段的主要任务仅仅只是标记处GC ROOTS能直接关联对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较少，速度很快。</li><li>并发标记阶段：从GC Roots的直接关联对象开始遍历整个对象图过程，这个过程耗时比较长，与用户线程一起并行执行。</li><li>重新标记：修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。（STW）</li><li>并发清除：清除删除掉标记阶段判断已经死亡的对象，释放空间</li></ul><p><strong>示意图</strong></p><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器CMS/image-20201231091620401.png" alt="image-20201231091620401" style="zoom:80%;"><p>尽管CMS收集器采用的是并发回收，但在其初始化标记和再次标记这两个阶段中仍然会出现STW，不过暂停时间不会太长，因此说明所有垃圾收集器都做不到完全不需要STW,只是尽可能地缩短暂停时间。</p><p>由于垃圾收集阶段用户没有线程中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可见。CMS收集器不能像其他收集器那样等到老年代几乎完全填满了再去收集，而是当堆内存使用率达到某一个阈值时，便开始回收。以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器进行老年代的垃圾收集，这样停顿就会很长。</p><p><strong>CMS的优点：</strong></p><ul><li>并发收集</li><li>低延迟</li></ul><p><strong>CMS的弊端</strong></p><ul><li>产生碎片化</li><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾</li></ul><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p><strong>-XX:+UseConcMarkSweepGC</strong></p><p>手动指定使用CMS，收集器执行内存回收任务。开启该参数后会自动将-XX:+UseParNewGC打开，即ParNew+CMS+Serial Old组成</p><p><strong>-XX:CMSlnitiatingOccupanyFraction</strong></p><p>设置堆内存使用率的阈值，一旦到达阈值，即开始进行回收</p><ul><li>JDK5以及以前版本默认为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收，JDK6以上默认值92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用增长率很快，则可以降低这个阈值，以避免触发Serial Old进行收集。</li></ul><p><strong>-XX:+UseCMSCompactAtFullCollection</strong></p><p>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片产生。不过由于内存压缩整理过程无法并行执行，带来问题停顿时间更长了。</p><p><strong>-XX:CMSFullGSsBeforeCompaction</strong></p><p>设置在执行多少次Full GC后对内存进行压缩整理。</p><p><strong>-XX:ParallelCMSThreads</strong></p><p>设置线程数量。</p><p>CMS默认启动线程数是（ParallelGCTheads+3）/4，ParallelGCTheads 是年轻代收集器线程数，当CPU资源比较紧张，受CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h2 id="JDK后续版本中CMS的变化。"><a href="#JDK后续版本中CMS的变化。" class="headerlink" title="JDK后续版本中CMS的变化。"></a>JDK后续版本中CMS的变化。</h2><ul><li>JDK9新特性：CMS被标记为Deprecate了（JEP291）,如果对JDK9及以上版本HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个告警信息，提示CMS未来将会被废弃。</li><li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除CMS垃圾回收器。如果在JDK14设置XX:+UseConcMarkSweepGC的话，JVM不会报错，只有给出一个warning信息，但是不会exit。JVM会自动回退默认GC方式启动JVM</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在JDK 1.5时期，HotSpot推出一款在强交互应用中几乎认为有划时代意义的垃圾收集器：CMS(Concurrent-Mar
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收器" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之垃圾回收器Parallel</title>
    <link href="https://jameslin23.gitee.io/2020/12/30/JVM%E7%AF%87%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8Parallel/"/>
    <id>https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Parallel/</id>
    <published>2020-12-30T12:58:15.000Z</published>
    <updated>2021-01-09T10:41:45.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/image-20201230202351458.png" alt="image-20201230202351458" style="zoom:50%;"><p>图中展示了7种作用于不同分代的收集器，如果两个收集器相连，说明他们可以搭配使用。虚拟机所处区域表示它是属于新生代还是老年代收集器</p><p><strong>新生代收集器</strong>：Serial、ParNew、Paraller Scavenge</p><p><strong>老年代收集器</strong>：CMS、Serial Old、Parallel Old</p><p><strong>整堆收集器</strong>：G1</p><h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>吞吐量优先的垃圾回收器，<strong>jdk1.8</strong>默认垃圾回收器</p><p><strong>特点：</strong>属于新生代收集器，复制算法，并行的多线程收集器。</p><p>该收集器的目标是达到一个可控制的吞吐量，还有一个值得关注点：GC自适应调节策略</p><p><strong>GC自适应调节策略</strong>：可设置-XX:+UseAdptiveSizePolicy参数，当开关打开时不需要手动指定新生代的大小（-xmn）、Eden与Surivor区的比例（-XX:SurvivorRation）、晋升老年代年龄（-XX：PretenureSizeThreshold）等。虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li><strong>XX:MaxGCPauseMillis</strong> 控制最大垃圾收集停顿时间</li><li><strong>XX:GCRatio</strong> 直接设置吞吐量大小</li></ul><h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p>是Parallel Scavenge收集器的老年代版本</p><p>特点：多线程，采用标记-压缩算法</p><p>Ps/Po工作示意图</p><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Parallel/image-20201231083018420.png" alt="image-20201231083018420" style="zoom:80%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;img src=&quot;https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/image-2
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收器" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之垃圾回收器Serial</title>
    <link href="https://jameslin23.gitee.io/2020/12/30/JVM%E7%AF%87%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8Serial/"/>
    <id>https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/</id>
    <published>2020-12-30T12:21:10.000Z</published>
    <updated>2021-01-09T10:40:13.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/image-20201230202351458.png" alt="image-20201230202351458" style="zoom:50%;"><p>图中展示了7种作用于不同分代的收集器，如果两个收集器相连，说明他们可以搭配使用。虚拟机所处区域表示它是属于新生代还是老年代收集器</p><p><strong>新生代收集器</strong>：Serial、ParNew、Paraller Scavenge</p><p><strong>老年代收集器</strong>：CMS、Serial Old、Parallel Old</p><p><strong>整堆收集器</strong>：G1</p><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>serial收集器是最基本、发展历史最悠久的收集器。</p><p><strong>特点：</strong>单线程、简单高效，对应当个CPU的环境，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然获得最高单线程效率，</p><p>收集进行垃圾时，必须暂停其他所有的工作线程（Stop The World）,直到它结束。</p><p><strong>运用场景</strong>：适用于Clinet模式下的虚拟机</p><p>Serial/Serial Old收集器运用图</p><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/image-20201230203617306.png" alt="image-20201230203617306" style="zoom: 80%;"><h2 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h2><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用标记-压缩算法</p><p><strong>应用场景</strong>：适用于Clinet模式下的虚拟机</p><ul><li>在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用</li><li>作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用</li></ul><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>ParNew收集器其实是Serial收集器的多线程版本。</p><p>除了使用多线程其余均行为均和Serial收集器一模一样（参数控制、收集算法、Stop the World、对象分配规则、回收策略）</p><p><strong>特点：</strong>多线程、ParNew收集器默认开启的收集线程与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾回收器的线程数。</p><p><strong>应用场景：</strong>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，他经常与CMS搭配。</p><p>ParNew/Serial Old组合收集器示意图</p><img src="https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/image-20201230205646468.png" alt="image-20201230205646468" style="zoom:80%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;img src=&quot;https://jameslin23.gitee.io/2020/12/30/JVM篇之垃圾回收器Serial/image-2
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收器" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之标记压缩算法</title>
    <link href="https://jameslin23.gitee.io/2020/12/30/JVM%E7%AF%87%E4%B9%8B%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    <id>https://jameslin23.gitee.io/2020/12/30/JVM篇之标记压缩算法/</id>
    <published>2020-12-30T12:06:38.000Z</published>
    <updated>2021-01-03T05:35:36.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>复制算法的高效是建立在存活对象少的、垃圾对象多的前提下。这种情况在新生代经常发生，但是在老年代，更常见的情况大部分对象都是存活对象，如果采用复制算法，由于存活对象多，复制成本也很高，因此老年代垃圾回收特征，需要使用其他算法。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul><li>第一阶段和标记清除一样，从根节点开始标记所有被引用对象。</li><li>第二阶段将所有存活的对象压缩到内存的一段，按顺序排放。</li><li>之后清理边界外所有空间。</li></ul><h2 id="内存图示"><a href="#内存图示" class="headerlink" title="内存图示"></a>内存图示</h2><img src="https://img-blog.csdnimg.cn/20200729101847716.png" alt="img" style="zoom:80%;"><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>从效率来看，标记-整理算法要低于复制算法</li><li>移动对象的同时，如果对象被其它对象引用，则需要调整引用地址</li><li>移动过程中需要全程暂停用户应用，即STW。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标记-压缩算法&quot;&gt;&lt;a href=&quot;#标记-压缩算法&quot; class=&quot;headerlink&quot; title=&quot;标记-压缩算法&quot;&gt;&lt;/a&gt;标记-压缩算法&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收算法" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之复制算法</title>
    <link href="https://jameslin23.gitee.io/2020/12/30/JVM%E7%AF%87%E4%B9%8B%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://jameslin23.gitee.io/2020/12/30/JVM篇之复制算法/</id>
    <published>2020-12-30T10:20:19.000Z</published>
    <updated>2020-12-30T12:06:42.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA Lisp Garbage Collector Algorithm Using Serial Secondary Storage”。M.L.Minsky在论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功的引入到了Lisp语言的一个实现版本中。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><h2 id="内存图示"><a href="#内存图示" class="headerlink" title="内存图示"></a>内存图示</h2><img src="https://img-blog.csdnimg.cn/20200729095325197.png" alt="img" style="zoom:80%;"><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>高效，且不产生碎片化</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>耗内存，需要两倍内存空间</li></ul><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>用于新生代，由于复制算法需要复制存活的对象到另外一边，所以新生代存活率并不高，所以适合使用新生代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复制算法&quot;&gt;&lt;a href=&quot;#复制算法&quot; class=&quot;headerlink&quot; title=&quot;复制算法&quot;&gt;&lt;/a&gt;复制算法&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收算法" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM篇之标记清除算法</title>
    <link href="https://jameslin23.gitee.io/2020/12/30/JVM%E7%AF%87%E4%B9%8B%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95/"/>
    <id>https://jameslin23.gitee.io/2020/12/30/JVM篇之标记清除算法/</id>
    <published>2020-12-30T09:19:13.000Z</published>
    <updated>2020-12-30T10:20:33.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为Stop The World），然后进行两项工作，第一项是标记，第二项则是清除。</p><ul><li>标记：从引用根节点开始遍历，标记所有被引用对象。一般是在对象Header中记录为可达对象。</li><li>清除：对堆内内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记可达对象，则其将回收。</li></ul><h2 id="内存图示"><a href="#内存图示" class="headerlink" title="内存图示"></a>内存图示</h2><img src="https://img-blog.csdnimg.cn/20200729093822729.png" alt="img" style="zoom:80%;"><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>内存碎片化严重</li><li>效率不高</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标记清除算法&quot;&gt;&lt;a href=&quot;#标记清除算法&quot; class=&quot;headerlink&quot; title=&quot;标记清除算法&quot;&gt;&lt;/a&gt;标记清除算法&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JVM" scheme="https://jameslin23.gitee.io/categories/JVM/"/>
    
    
      <category term="垃圾回收算法" scheme="https://jameslin23.gitee.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized分析篇</title>
    <link href="https://jameslin23.gitee.io/2020/12/28/Synchronized%E5%88%86%E6%9E%90%E7%AF%87/"/>
    <id>https://jameslin23.gitee.io/2020/12/28/Synchronized分析篇/</id>
    <published>2020-12-28T12:24:22.000Z</published>
    <updated>2020-12-29T03:52:43.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>synchronized是java提供的原子性内置锁（存在对象头里面），这种内置的并且使用者看不到的锁也称为监视器锁，使用synchronized之后，会在编译之后的同步代码块前面加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。它的作用主要就是要实现原子性操作和解决共享变量的内存可见性。</p><p>执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁或者已经获得锁，锁的计数器+1.此时其它竞争锁的线程则进入等待队列中。</p><p>执行monitorexit指令会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争。</p><p>synchronized是排它锁，当一个线程获得锁之后，其它线程必须等待该线程释放锁才能获得锁，而且由于java中的线程和操作系统原生线程是一一对应，线程被阻塞或者唤醒时会从用户态切换到内核态，非常消耗性能。</p><p>Synchronized实际有两个队列waitSet和entryList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _owner        = NULL; <span class="comment">// 运行的线程</span></span><br><span class="line">    <span class="comment">//两个队列</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//调用 wait 方法会被加入到_WaitSet</span></span><br><span class="line">   _EntryList    = NULL ; <span class="comment">//锁竞争失败，会被加入到该列表</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Synchronized&quot;&gt;&lt;a href=&quot;#Synchronized&quot; class=&quot;headerlink&quot; title=&quot;Synchronized&quot;&gt;&lt;/a&gt;Synchronized&lt;/h2&gt;&lt;p&gt;synchronized是java提供的原子性内置锁（存在对
      
    
    </summary>
    
      <category term="并发编程" scheme="https://jameslin23.gitee.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Synchronized" scheme="https://jameslin23.gitee.io/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析</title>
    <link href="https://jameslin23.gitee.io/2020/12/28/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jameslin23.gitee.io/2020/12/28/AQS源码分析/</id>
    <published>2020-12-28T08:26:22.000Z</published>
    <updated>2021-01-07T03:56:41.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS简单介绍"><a href="#AQS简单介绍" class="headerlink" title="AQS简单介绍"></a>AQS简单介绍</h2><p>AQS定义两种资源：Exclusive(独占，只有一个线程能执行，如果ReentranLock) 和 Share(共享，多个线程可同时执行，如Semaphore/CountDownLatch)。</p><p>不同的自定义同步器争用共享的方式也不同。自定义同步器实现时只需要实现共享资源state的获取和释放即可。至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了，自定义同步器实现主要实现以下几种方法：</p><ul><li><strong>isHeldExclusively()</strong>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><strong>tryAcquire(int)</strong>：独占方式，尝试获取资源，成功则返回true,失败返回false。</li><li><strong>tryRelease(int)</strong>：独占方式，尝试释放资源，成功则返回true,失败返回false。</li><li><strong>tryAcquireShared(int)</strong>：共享方式，尝试获取资源，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</li><li><strong>tryReleaseShared(int)</strong>：共享方式，尝试释放资源，如果释放后允许唤醒后续等待节点返回true,否则返回false</li></ul><p><strong>以ReentrantLock为例</strong></p><p>state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占锁并将state+1。此后，其它线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。释放之前，A线程自己可以重复获取此锁（state会累积），这是锁重入概念，但是主要，获取多少次就要释放多少次，这样才能保证state是能回到零。</p><p><strong>CountDownLatch为例</strong></p><p>任务分为N个子线程去执行，state也初始化为N（N和线程数一直）。这N个线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS-1,等到所有子线程都执行后（既state=0）,会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p>Node节点是对每一个等待获取资源的线程封装，其包含了需要同步线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否被取消等。变量waitStatus则表示当前Node节点的等待状态，共有5种取值</p><ul><li><strong>CANCELLED(1)</strong>：表示当前节点已经取消调度。当timeout或者被中断（响应中断的情况下），会触发变更此状态，进入该状态后的节点将不会再变化。</li><li><strong>SIGNAL(-1)</strong>：表示<strong>后继节点</strong>在等待前节点唤醒。后续节点入队时，会将前继节点的状态更新为SIGNAL。</li><li><strong>CONDITION(-2)</strong>：表示节点等待在Condition上，当其他线程调用condition的signal()方法后，CODIOTION状态节点从等待队列转移同步队列</li><li><strong>PROPAGATE(-3)</strong>：共享模式下，前继节点不仅会唤醒后继节点，同时也可能唤醒后继的后继节点。</li><li><strong>0</strong>：新节点入队时默认状态。</li></ul><p>负值表示节点处于有效等待状态，而正值表示结点已被取消。</p><h3 id="独占方式"><a href="#独占方式" class="headerlink" title="独占方式"></a>独占方式</h3><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p><strong>acquire(int)</strong></p><p>此方法是独占模式下线程共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取资源为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法如下：</p><ul><li>tryAcquire()尝试直接获取资源，如果成功则直接返回（这里体现了非公平，每个线程获取锁时会直接抢占一次）</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式</li><li>acquireQueued()使得线程阻塞在等待队列中获取资源，一直获取到资源才返回。如果整个过程中被中断，则返回true,否则返回false</li><li>如果线程在等待队列中被中断过，他是不响应的，只有获取资源后才进行自我中断selfInterrupt()，将中断补上</li></ul><p><strong>addWaiter(Node)</strong></p><p>此方法用于将当前线程加入等待队列的队尾，并返回当前线程所在的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：该入队方法的返回值就是新创建的节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//基于当前线程，节点类型（Node.EXCLUSIVE）创建新的节点</span></span><br><span class="line">       <span class="comment">//由于这里是独占模式，因此节点类型就是Node.EXCLUSIVE</span></span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="comment">//这里为了提搞性能，首先执行一次快速入队操作，即直接尝试将新节点加入队尾</span></span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="comment">//这里根据CAS的逻辑，即使并发操作也只能有一个线程成功并返回，其余的都要执行后面的入队操作。即enq()方法</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>enq(node)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整的入队操作</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//自旋，直到成功加入队列</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="comment">//如果队列还没有初始化，则进行初始化，即创建一个空的头节点</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">              <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// //正常流程，放入队尾</span></span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="comment">//该循环体唯一退出的操作，就是入队成功（否则就要无限重试）</span></span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>acquireQueued(Node,int)</strong></p><p>通过tryAcquire()和addWaiter(),该线程获取资源失败，已经被放入队列尾部了。那线程下一步操作该干什么呢？</p><p>进入等待状态休息，直到其它线程彻底释放资源后唤醒自己。acquireQueued类似跟医院排队拿号，在等待队列中排队拿号，中间没有其它事可以做，可以休息，直到拿到号在返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 成功获取资源</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其它就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shouldParkAfterFailedAcquire（Node,Node）</strong></p><p>此方法主要用于检查状态，看看自己是否可以被挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以被挂起</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程，如果前驱节点状态不是SIGNAL，那么自己不能安心去休息（挂起），需要遍历前驱节点，找到正常可以唤醒自己的前驱节点。</p><p><strong>parkAndCheckInterrupt()</strong></p><p>如果线程找到可以唤醒自己前驱节点，也就是前驱节点的状态时SIGNAL,就可以挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     LockSupport.park(<span class="keyword">this</span>);<span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted();<span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>park()会让自己线程进入waiting状态，在此状态下，有两种途径可以唤醒该线程</p><ul><li><strong>unpark()</strong></li><li><strong>interrupt()</strong></li></ul><p><strong>cancelAcquire(node)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的方法参数是当前获取锁资源失败的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果节点不存在则直接忽略</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过所有已经取消的前置节点，跟上面的那段跳转逻辑类似</span></span><br><span class="line">        Node pred = node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        <span class="comment">//这个是前置节点的后继节点，由于上面可能的跳节点的操作，所以这里可不一定就是当前节点，仔细想一下。^_^</span></span><br><span class="line">        Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前节点waitStatus置为取消，这样别的节点在处理时就会跳过该节点</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line">        <span class="comment">//如果当前是尾节点，则直接删除，即出队</span></span><br><span class="line">        <span class="comment">//注：这里不用关心CAS失败，因为即使并发导致失败，该节点也已经被成功删除</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//这里的判断逻辑很绕，具体就是如果当前节点的前置节点不是头节点且它后面的节点等待它唤醒（waitStatus小于0），</span></span><br><span class="line">                    <span class="comment">//再加上如果当前节点的后继节点没有被取消就把前置节点跟后置节点进行连接，相当于删除了当前节点</span></span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//进入这里，要么当前节点的前置节点是头结点，要么前置节点的waitStatus是PROPAGATE，直接唤醒当前节点的后继节点</span></span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结：首先会先调用tryacquire()方法尝试获取锁，如果获取得到就直接返回，通过addwaiter()方法创建一个node节点，通过CAS加入队列尾部，会一直尝试，直到成功为止。加入成功的node节点就会执行acquireQueued方法，这个办法主要是判断线程前驱节点是不是头节点，并尝试去获取资源，如果符合条件就退出自旋，并返回。如果获取不到就会进入判断是否可以挂起线程，如果可以就执行lockSupport.park挂起该线程， 等待其它线程唤醒。</strong></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 0表示没有其它被唤醒的节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//把标记为设置为0，表示唤醒操作已经开始进行，提高并发环境下性能</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//如果当前节点的后继节点为null，或者已经被取消</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//注意这个循环没有break，也就是说它是从后往前找，一直找到离当前节点最近的一个等待唤醒的节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行唤醒操作</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：先将状态设置为0，从后往前找，找到离当前节点最近的一个等待唤醒的节点，进行unpark。</p><h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><h4 id="获取锁-1"><a href="#获取锁-1" class="headerlink" title="获取锁"></a>获取锁</h4><p><strong>acquireShared(int)</strong></p><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指<strong>定量</strong>的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ul><li>tryAcquireShared()尝试获取资源，成功则直接返回</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回</li></ul><p><strong>doAcquireShared(int)</strong></p><p>此方法用于当前线程加入等待队列休息，直到其它线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//加入队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">//如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setHeadAndPropagate(node, r)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：首先tryAcquireShared去获取锁，如果返回值小于0说明没有剩余资源，进入同步队列。拿到队列的第二个节点去尝试获取资源。成功就将自己设置头节点，判断是否有资源继续唤醒后继节点</strong></p><h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><p><strong>releaseShared()</strong></p><p>此方法是共享模式下线程释放共享资源的顶层入口，它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其它线程来获取资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doReleaseShared()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：释放资源，唤醒后继</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AQS简单介绍&quot;&gt;&lt;a href=&quot;#AQS简单介绍&quot; class=&quot;headerlink&quot; title=&quot;AQS简单介绍&quot;&gt;&lt;/a&gt;AQS简单介绍&lt;/h2&gt;&lt;p&gt;AQS定义两种资源：Exclusive(独占，只有一个线程能执行，如果ReentranLock) 和
      
    
    </summary>
    
      <category term="并发编程" scheme="https://jameslin23.gitee.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AQS" scheme="https://jameslin23.gitee.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS原理分析</title>
    <link href="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://jameslin23.gitee.io/2020/12/27/AQS原理分析/</id>
    <published>2020-12-27T07:17:02.000Z</published>
    <updated>2021-01-09T10:36:52.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h2><p>AQS(Abstract Queued Synchronizer) 抽象队列同步器，定义了一套多线程访问共享资源的同步框架，许多同步类实现都依赖与它，常用ReentrantLock/Semaphoe/CountDownLatch</p><p>由一个资源状态int state和同步器（FIFO双向阻塞队列组成）</p><p><img src="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201227152453788.png" alt="image-20201227152453788"></p><h3 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h3><p>同步器依赖内部的同步队列（FIFO）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会使用<strong>CAS</strong>将当前线程以及等待状态等信息构造成一个节点Node并将其加入同步队列<strong>尾部</strong>，同时会阻塞当前线程，当同步状态释放时，会把首节点的线程唤醒，并其再尝试获取同步状态。</p><p>同步队列的节点Node用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p><p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后续节点，而后续节点将会在获取同步状态成功时将自己设置为首节点。</p><p><strong>注：由于获取成功状态的线程只有一个，所有设置首节点不需要使用cas，而插入尾部竞争的线程有很多个，所以需要使用CAS。</strong></p><p><img src="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201227170001772.png" alt="image-20201227170001772"></p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>同步器的acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码主要完成同步锁状态获取、节点构造、加入同步队列以及在同步队列中自旋等待相关工作。</p><p>其主要逻辑是：首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点并通过addWaiter(Node node)方法将节点加入到同步队列的尾部,最后调用acquireQueued(Node node,int arg)方法，<strong>使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或者阻塞线程中断来实现。</strong></p><p>当前线程在“死循环”中获取同步状态，而只有前驱节点是头节点才能尝试获取同步状态，这个为什么？</p><ul><li><strong>头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</strong></li><li><strong>维护同步队列的FIFO原则</strong></li></ul><p><strong>总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程通过CAS加入到队列尾部并在队列中；移除队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态。然后唤醒头节点后继节点。</strong></p><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>共享式获取与独占式获取最主要的区别是在与同一个时刻能有多个线程获取同步状态</p><p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是<strong>tryAcquireShared(int arg)方法返回值大于等于0</strong>。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p><p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShard</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryReleaseShard(arg))&#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reture <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过<strong>循环</strong>和<strong>CAS</strong>来保证的，因为释放同步状态的操作会同时来自多个线程。</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>任意一个java对象，都拥有一组监视器方法（定义在object上）,主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与Synchronized同步关键字配合,可以实现等待/通知。condition接口也提供了类似Object的监听器方法，与Lock配合可以实现等待/通知模式。</p><p>Object的监听器方法与Condition接口的对比</p><table><thead><tr><th>对比项</th><th>Object</th><th>Condition</th></tr></thead><tbody><tr><td>前置条件</td><td>获取对象锁</td><td>调用Lock.lock()获取对象锁，调用Lock.newCondition()获取Condition对象</td></tr><tr><td>调用方式</td><td>直接调用</td><td>直接调用，例如condition.await()</td></tr><tr><td>等待队列个数</td><td>一个</td><td>多个</td></tr><tr><td>当前线程释放锁进入等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入等待状态，在等待状态中不响应中断</td><td>不支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入超时等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入等待状态到将来的某个时间</td><td>不支持</td><td>支持</td></tr><tr><td>唤醒等待队列中一个线程</td><td>支持</td><td>支持</td></tr><tr><td>唤醒等待队列中全部线程</td><td>支持</td><td>支持</td></tr></tbody></table><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>ConditionObject是同步器AQS的内部类，因为Condition的操作需要相关联的锁，所以作为同步器的内部类也比较合理。每个condition对象都包含一个队列，该队列是Condition对象实现等待/通知功能的关键。</p><p><strong>等待队列</strong></p><p>等待队列是一个FIFO的队列，在队列中每个节点都包含一个线程引用，该线程就是在condition对象等待的线程，如果一个线程调用了condition.await()方法，那么该线程将会释放锁，构造成节点加入等待队列并进行等待中。实际上，节点的定义复用了同步器中节点的定义，也就是说，<strong>同步队列和等待队列中节点类型都是同步器静态内部类</strong></p><p>一个Condition包含一个等待队列，Condition拥有首节点firstWaiter和尾节点lastWaiter。当前线程调用Condtion.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列基本构造</p><p><img src="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201227172155980.png" alt="image-20201227172155980"></p><p>Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。<strong>更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定获取了锁的线程，也就是该过程是由锁来保证线程安全的。</strong></p><p>在Object的监视器模式上，一个对象拥有一个同步队列和等待队列</p><p><strong>在Lock拥有一个同步队列和多个等待队列。</strong></p><p><img src="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201227173153293.png" alt="image-20201227173153293"></p><p>Condition的实现是同步器的内部类，因此每个condition实例都能够访问同步器提供的方法，相当于每个condition都拥有所属同步器的引用。</p><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，想当于同步队列的首节点（获取锁的节点）移动到Condition的等待队列中。</p><p><code>ConditionObject的await方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">       Node node = addConditionWaiter();</span><br><span class="line">      <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">      <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">      <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">          interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">          unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法的线程成功获取了锁的线程，也就是同步队里的首节点，该方法会将当前线程构造节点并加入等到队里中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态</p><p>当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><p><img src="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201227174555960.png" alt="image-20201227174555960"></p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>调用condition的signal()方法，将会在唤醒等待队列中等待时间最长的节点（首节点），在唤醒之前，将节点移到同步队列。</p><p><code>ConditionObject的signal方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      Node first = firstWaiter;</span><br><span class="line">       <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">       doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法的前置条件是当前线程必须获取锁，可以看到signal()进行了isHeldExclusively()检查，也就是当前线程必须获取了锁的线程，接着获取等待队列的首节点，将其移动到同步队列并使用<strong>LockSupport</strong>唤醒节点中的线程。</p><p><img src="https://jameslin23.gitee.io/2020/12/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20201227175438751.png" alt="image-20201227175438751"></p><p>通过调用同步器的enq(Node node)方法，等待队列中节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>被唤醒的线程，将从await()方法中的while循环中退出，进而调用同步器的acquireQueued()方法加入获取同步状态的竞争中。</p><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AQS概述&quot;&gt;&lt;a href=&quot;#AQS概述&quot; class=&quot;headerlink&quot; title=&quot;AQS概述&quot;&gt;&lt;/a&gt;AQS概述&lt;/h2&gt;&lt;p&gt;AQS(Abstract Queued Synchronizer) 抽象队列同步器，定义了一套多线程访问共享资源的同
      
    
    </summary>
    
      <category term="并发编程" scheme="https://jameslin23.gitee.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="AQS" scheme="https://jameslin23.gitee.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="https://jameslin23.gitee.io/2020/12/26/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jameslin23.gitee.io/2020/12/26/ArrayList源码分析/</id>
    <published>2020-12-26T06:07:16.000Z</published>
    <updated>2020-12-27T13:38:11.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化版本UID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span></span><br><span class="line">        serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span></span><br><span class="line">        DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> * new ArrayList(0);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]</span><br><span class="line">        EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于提供默认大小的实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> * new ArrayList();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]</span><br><span class="line">        DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList元素的数组缓冲区</span></span><br><span class="line"><span class="comment"> * ArrayList的容量，是数组的长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * non-private to simplify nested class access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList中元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>无参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法 将elementData 赋值为</span></span><br><span class="line"><span class="comment"> *   DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData =</span><br><span class="line">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带初始容量构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带一个初始容量参数的构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  如果初始容量非法就抛出</span></span><br><span class="line"><span class="comment"> *          IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData =</span><br><span class="line">                <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带一个集合参数的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带一个集合参数的构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 集合，代表集合中的元素会被放到list中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 如果集合为空，抛出NullPointerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 如果 size != 0</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray 可能不正确的，不返回 Object[]</span></span><br><span class="line">        <span class="comment">// https://bugs.openjdk.java.net/browse/JDK-6260652</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(</span><br><span class="line">                    elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// size == 0</span></span><br><span class="line">        <span class="comment">// 将EMPTY_ELEMENTDATA 赋值给 elementData</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="扩容分析"><a href="#扩容分析" class="headerlink" title="扩容分析"></a>扩容分析</h2><p>这里以无参构造函数创建的 ArrayList 为例分析：</p><p><strong>add方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">         ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>ensureCapacityInternal方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// DEFAULT_CAPACITY=10,</span></span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> minCapacity;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由代码可知道，当add进第一个元素时，mincapacity是1，Math.max方法比较后，返回最大值是10</p><p><strong>ensureExplicitCapacity方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当add进第一个元素到ArrayList时，elementData.length为0(因为第一个空的list),因为执行了ensureCapacityInternal()方法，所以minCapacity此时为10，此时minCapacity - elementData.length &gt; 0 成立，所以会进入 grow(minCapacity) 方法。</li><li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</li><li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li><li>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</li></ul><p>grow()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2</span></span><br><span class="line">    <span class="comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，19        //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE                   MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ArrayList是属于动态扩容，当你未指定容量大小时，默认容量是10，每次add时候会判断当前长度+1-容量大小是否大于0。<br>如果是，就会进行扩容，扩容新容量=旧容量+旧容量右移1位，也就是原来的1.5倍左右，此时会进行2个大小判断，一个判断是否小于最小容量，如果小于就取最小容量为新的容量，再次判断新容量是否&gt;inter.max.value-8,大于新的容量取integer.max.value。</p><p><strong>本质就是计算出新的容量实例化数组，将原有的数组内容复制到新的数组去。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="java基础" scheme="https://jameslin23.gitee.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java集合" scheme="https://jameslin23.gitee.io/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试篇</title>
    <link href="https://jameslin23.gitee.io/2020/12/26/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>https://jameslin23.gitee.io/2020/12/26/java基础面试篇/</id>
    <published>2020-12-26T01:31:02.000Z</published>
    <updated>2020-12-26T01:34:28.791Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="面试专题" scheme="https://jameslin23.gitee.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="java" scheme="https://jameslin23.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>gateway</title>
    <link href="https://jameslin23.gitee.io/2020/12/25/gateway/"/>
    <id>https://jameslin23.gitee.io/2020/12/25/gateway/</id>
    <published>2020-12-25T07:54:18.000Z</published>
    <updated>2020-12-25T09:21:37.395Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="springCloud" scheme="https://jameslin23.gitee.io/categories/springCloud/"/>
    
    
      <category term="服务网关" scheme="https://jameslin23.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix</title>
    <link href="https://jameslin23.gitee.io/2020/12/25/Hystrix/"/>
    <id>https://jameslin23.gitee.io/2020/12/25/Hystrix/</id>
    <published>2020-12-25T02:43:36.000Z</published>
    <updated>2020-12-25T06:36:02.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hystrix是一个用于分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等。Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障。以提高分布式系统的弹性。</p><p>“断路器”本身是在一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，像调用方返回一个符合预期的，可处理的备选响应（FallBack）,而不是长时间的等待或者抛出调用方无法处理异常。避免服务调用方的线程不会被长时间，不必要的占用，从而避免故障在分布式系统中蔓延，乃至雪崩。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>服务器忙，请稍后再试，不让客户等待并立刻返回一个友好提示，fallback。</p><p>以下情况会触发降级</p><ul><li><strong>程序运行异常</strong></li><li><strong>超时</strong></li><li><strong>服务熔断触发服务降级</strong></li><li><strong>线程池/信号量打满</strong></li></ul><p><strong>Demo</strong></p><p>服务A–当有很多个客户端请求时，该服务接口被困死，因为tomcat线程里面的工作线程已经被挤占完毕</p><p>服务B–调用A服务客户端访问响应缓慢，转圈圈</p><p>A服务限流配置<code>@HystrixCommand</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 失败</span></span><br><span class="line">  <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfo_TimeOutHandler"</span>,commandProperties = &#123;</span><br><span class="line">          <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value = <span class="string">"3000"</span>) &#125;)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>  timeNumber = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"线程池："</span>+Thread.currentThread().getName()+<span class="string">"   paymentInfo_TimeOut,id：  "</span>+id+<span class="string">"\t"</span>+<span class="string">"呜呜呜"</span>+<span class="string">" 耗时(秒)"</span>+timeNumber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//兜底方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"线程池："</span>+Thread.currentThread().getName()+<span class="string">"   系统繁忙, 请稍候再试  ,id：  "</span>+id+<span class="string">"\t"</span>+<span class="string">"哭了哇呜"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动配置增加注解<code>@EnableCircuitBreaker</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B服务设置服务降级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentTimeOutFallbackMethod"</span>,commandProperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value = <span class="string">"1500"</span>)  <span class="comment">//3秒钟以内就是正常的业务逻辑</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//兜底方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题</strong></p><ul><li>每个controller配置一个</li><li>和业务逻辑混合在一起</li></ul><p><strong>解决方案</strong></p><p>重新新建一个类（PaymentFallbackService）实现该接口，统一为feign接口里面的方法进行异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_OK , (┬＿┬)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_TimeOut , (┬＿┬)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feign接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span><span class="comment">//,fallback = PaymentFallbackService.class</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span>,fallback = PaymentFallbackService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span> <span class="comment">#如果处理自身的容错就开启。开启方式与生产端不一样。</span></span><br></pre></td></tr></table></figure><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p><p><strong>熔断机制</strong></p><p>熔断机制是应对雪崩的一种微服务链路保护机制。当某个服务出错不可用或者响应时间太长了时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。</p><p>当检测到该节点微服务调用响应正常后，恢复链路调用</p><p>在spring cloud框架中，熔断机制通过Hystrix实现，Hystrix会监控微服务调用的状况，当失败的调用到一定阈值，缺省5秒内20调用失败，就会启动熔断机制。</p><p><strong>服务层配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span>,commandProperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span>,value = <span class="string">"true"</span>),  <span class="comment">//是否开启断路器</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>,value = <span class="string">"10"</span>),   <span class="comment">//请求次数</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value = <span class="string">"10000"</span>),  <span class="comment">//时间范围</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>,value = <span class="string">"60"</span>), <span class="comment">//失败率达到多少后跳闸</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (id <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"*****id 不能负数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">String serialNumber = IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"调用成功,流水号："</span>+serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"id 不能负数，请稍候再试,(┬＿┬)/~~     id: "</span> +id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>熔断状态</strong></p><ul><li>熔断打开</li><li>熔断关闭</li><li>熔断半开</li></ul><h2 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h2><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><h2 id="服务监控hystrixDashboard"><a href="#服务监控hystrixDashboard" class="headerlink" title="服务监控hystrixDashboard"></a>服务监控hystrixDashboard</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Hystrix是一个用于分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等。Hystrix能够保
      
    
    </summary>
    
      <category term="springCloud" scheme="https://jameslin23.gitee.io/categories/springCloud/"/>
    
    
      <category term="服务降级" scheme="https://jameslin23.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>OpenFeign</title>
    <link href="https://jameslin23.gitee.io/2020/12/25/OpenFeign/"/>
    <id>https://jameslin23.gitee.io/2020/12/25/OpenFeign/</id>
    <published>2020-12-25T01:42:40.000Z</published>
    <updated>2020-12-25T02:43:50.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可</p><p>Feign使得Java Http客户端变得更容易。Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化的调用方法。但实际开发的调用可能不止一处。往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装。Feign在基础上做了进一步封装。由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要<strong>创建一个接口并使用注解的方式来配置它</strong>，即可完成对服务提供方 的接口绑定，简化了使用Ribbon,自动封装服务调用客户端的开发量。</p><h3 id="Feign-amp-OpenFeign"><a href="#Feign-amp-OpenFeign" class="headerlink" title="Feign &amp; OpenFeign"></a>Feign &amp; OpenFeign</h3><ul><li><p>Feign是Springcloud组件中的一个轻量级Restful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>OpenFeign是springcloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Feign接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value=<span class="string">"content"</span>) <span class="comment">// 服务名</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/content"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContentFeign</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 根据分类ID查询所有广告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/list/category/&#123;id&#125;"</span>)</span><br><span class="line">    Result&lt;List&lt;Content&gt;&gt; findByCategory(<span class="meta">@PathVariable</span>(name = <span class="string">"id"</span>) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类扫描对应接口包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages= &#123;<span class="string">"com.haigou.content.feign"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>OpenFeign默认等待一秒钟，超时后报错</p><p>可以在YML文件开启OpenFeign客户端超时控制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">ReadTimeout:</span>  <span class="number">5000</span></span><br><span class="line"><span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>Feign提供了日志打印功能，对Feign接口调用情况进行控制和输出。</p><p><strong>配置Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>yml文件开启</strong>(xxx对应feign接口路径)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">xxx.xxx:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;Feign&quot;&gt;&lt;a href=&quot;#Feign&quot; class=&quot;headerlink&quot; title=&quot;Feign&quot;&gt;&lt;/a&gt;Feig
      
    
    </summary>
    
      <category term="springCloud" scheme="https://jameslin23.gitee.io/categories/springCloud/"/>
    
    
      <category term="服务调用" scheme="https://jameslin23.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ribbon</title>
    <link href="https://jameslin23.gitee.io/2020/12/25/Ribbon/"/>
    <id>https://jameslin23.gitee.io/2020/12/25/Ribbon/</id>
    <published>2020-12-25T00:30:48.000Z</published>
    <updated>2020-12-25T01:43:33.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>SpringCloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡</strong>的工具。是Netflix发布开源项目，主要功能提供客户端的软件<strong>负载均衡和服务调用</strong>。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。就是在配置文件中列出Load Balancer(Lb)后面的所有机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><h3 id="LB（负载均衡）"><a href="#LB（负载均衡）" class="headerlink" title="LB（负载均衡）"></a>LB（负载均衡）</h3><p>简单的来说就是将用户的请求平摊的分配到多个服务上,从而达到系统的HA(高可用)。常见的负载均衡有Nginx,LVS,硬件F5等。</p><p><strong>Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别</strong></p><p>Nginx是服务器负载均衡，客户端所有请求都会交给Nginx,然后由nginx实现转发请求。负载均衡由服务实现的。</p><p>Ribbon本地负载均衡，在调用微服务接口时，会在注册中心上获取信息服务列表之后缓存到JVM,从而在本地实现RPC远程服务调用。</p><p>总结：<strong>负载均衡+RestTemplate调用</strong></p><p><img src="/2020/12/25/Ribbon/C:%5CUsers%5CAdministrator.USER-20190627HM%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201225090457343.png" alt="image-20201225090457343"></p><p>Ribbon在工作时分两步</p><ul><li>先选择EurekaServer,他优先选择在同一个区域内负载比较少的server</li><li>再根据用户指定的策略，在从server取到服务注册列表中选择一个地址。其中Ribbon提供了多种策略: 比如轮询、随机和根据响应时间加权。</li></ul><p><strong>简单demo</strong></p><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">//赋予RestTemplate负载均衡的能力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">"http://CLOUD-PAYMENT-SERVICE"</span>;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">"/payment/get/"</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心组件IRule"><a href="#核心组件IRule" class="headerlink" title="核心组件IRule"></a>核心组件IRule</h2><h3 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h3><p>根据特定算法从服务列表中选取要访问的服务</p><ul><li><strong>RoundRobinRule</strong>  ：轮询</li><li><strong>RandomRule</strong> ：随机</li><li><strong>RetryRule</strong> ：先轮询策略获取服务，如果获取指定失败则在指定时间内进行重试</li><li><strong>weightedResponseTimeRule</strong>： 对RoundRobinRule的扩展，响应速度越快实例选择权越大，越容易被选择</li><li><strong>BestAvailableRule</strong> ：先会过滤掉由于多次访问故障而处于断路器跳闸状态的服务然后选择一个并大量最小的服务</li><li><strong>AvailabilityFilteringRule</strong>：先过滤掉故障实例，在选择并发最小的实例</li><li><strong>ZoneAvoidanceRule</strong>：默认规则，复合判断server所在区域的性能和server的可用性选择器</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>配置细节</strong></p><p>自定义配置类不能放在@componentScan所扫描的当前包下以及子包下，否则我们自定义的配置类就会被所有Ribbon客户端所共享，达不到特殊化定制目的。</p><p><img src="/2020/12/25/Ribbon/C:%5CUsers%5CAdministrator.USER-20190627HM%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201225093627726.png" alt="image-20201225093627726"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">// 随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>,configuration = MySelfRule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于Ribbon目前也进入维护模式，但是生产还是有大规模的使用，还是需要学习一下。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h
      
    
    </summary>
    
      <category term="springCloud" scheme="https://jameslin23.gitee.io/categories/springCloud/"/>
    
    
      <category term="服务调用" scheme="https://jameslin23.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
</feed>
