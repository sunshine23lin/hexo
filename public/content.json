{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://sunshine23lin.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-06-05T10:13:28.123Z","updated":"2019-06-05T08:00:18.919Z","comments":false,"path":"about/index.html","permalink":"https://sunshine23lin.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2019-06-06T09:51:35.223Z","updated":"2019-06-05T08:00:18.920Z","comments":false,"path":"repository/index.html","permalink":"https://sunshine23lin.github.io/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-06-05T10:13:28.124Z","updated":"2019-06-05T08:00:18.919Z","comments":false,"path":"books/index.html","permalink":"https://sunshine23lin.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-06-06T09:41:40.270Z","updated":"2019-06-05T08:00:18.919Z","comments":false,"path":"categories/index.html","permalink":"https://sunshine23lin.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-05T10:13:28.131Z","updated":"2019-06-05T08:00:18.920Z","comments":false,"path":"tags/index.html","permalink":"https://sunshine23lin.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-05T10:13:28.126Z","updated":"2019-06-05T08:00:18.919Z","comments":true,"path":"links/index.html","permalink":"https://sunshine23lin.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-05T10:07:54.870Z","updated":"2019-06-05T10:03:40.733Z","comments":true,"path":"categories/Spring/index.html","permalink":"https://sunshine23lin.github.io/categories/Spring/index.html","excerpt":"","text":"分类: Spring | Hexo 昵称 Web Developer &amp; Designer Shenzhen, China × Toggle navigation 首页 归档 分类 标签 项目 书单 友链 关于 公告 欢迎交流与分享经验! 分类 Spring3 标签 web后端1 标签云 web后端 归档 六月 20193 最新文章 Spring post11 2019-06-05 Spring 初步搭建spring 2019-06-05 Spring Hello World 2019-06-05 分类: Spring 共 3 篇文章 All Spring Spring (Total 3 articles) 2019-06-05 &nbsp;&nbsp;&nbsp; post11 2019-06-05 &nbsp;&nbsp;&nbsp; 初步搭建spring 2019-06-05 &nbsp;&nbsp;&nbsp; Hello World Theme by cofess base on pure. window.jQuery || document.write('') (function (window) { var INSIGHT_CONFIG = { TRANSLATION: { POSTS: '文章', PAGES: '页面', CATEGORIES: '分类', TAGS: '标签', UNTITLED: '(未命名)', }, ROOT_URL: '/', CONTENT_URL: '/content.json', }; window.INSIGHT_CONFIG = INSIGHT_CONFIG; })(window);"}],"posts":[{"title":"spring装配Bean","slug":"spring装配Bean","date":"2019-08-16T03:00:49.000Z","updated":"2019-08-16T08:14:41.075Z","comments":true,"path":"2019/08/16/spring装配Bean/","link":"","permalink":"https://sunshine23lin.github.io/2019/08/16/spring装配Bean/","excerpt":"","text":"Spring装配的可选方案Spring具有非常大的灵活性,提供三种主要的配置机制: 在XML中进行显示配置 在java中进行显示配置 隐式的bean发现机制和自动装配 注：尽可能地使用自动配置的机制。显示配置越少越好。当你必须要显示配置bean的时候,推荐使用类型安全并且比XML更加强大的JavaConfig。 自动化装配beanSpring从两个角度来自动化装配: 组件扫描:Spring会自动发现应用上下文中所创建的bean 自动装配:Spring自动满足bean之间的依赖 创建可被发现的bean例子:CD与CD播放器程序清单1.1 CompactDisc接口在Java中定义了CD 123public interface CompactDisc &#123; void play();&#125; 程序清单1.2 带有@Component注解的CompactDisc实现类SetPeppers 12345678910@Componentpublic class SgtPeppers implements CompactDisc&#123; private String title = \"Sgt. Pepper's Lonely Hearts Club Band\"; private String artist = \"The Beatles\"; public void play() &#123; System.out.println(\"Playing\" +title+\"by\" +artist); &#125;&#125; @Componet注解，表面该类会做为组件类,并告知Spring要为这个类创建bean。组件扫描默认是不启用的。我们还需要显示配置一下Spring,从而命令它去寻找带有@Componet注解的类,并起创建bean。 程序清单1.3 @ComponentScan注解启用了组件扫描 1234567891011@Configuration@ComponentScanpublic class CDplayerConfig &#123; @Bean public CompactDisc sgtPeppers()&#123; return new SgtPeppers(); &#125;&#125;// 如果没有其它配置的话,@ComponentScan默认会扫描与配置相同的包 程序清单1.4 通过XML启用组件扫描 1&lt;context:component-scan base-package=\"\"&gt; 为组件扫描的bean命名Spring应用上下中所有的bean都会给定一个ID。如果我们没有设置,但Spring会根据类名为其指定一个ID,将类名的第一个字母变为小写。 如果要为这个bean设置不同的ID,可以将ID作为值传递给@Component注解 @Component(“”) 另外一种为Bean命名方式,不使用@Component注解,而是使用java依赖注入规范中所提供的@Named注解来为bean设置ID 1234@Named(\"\")public class SgtPeppers implements CompactDics&#123;&#125; 设置组件扫描的基础包 123456789/** 第一种默认扫描当前的类包 @ComponentScan(\"\") 第二种扫描不同的基础配置包 @ComponentScan(basePackages=&#123;\"\",\"\"&#125;)*// 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法,在满足依赖的过程中会在Spring应用上下文中寻找匹配某个bean需求的其它bean。为了声明要进行自动装配,可以借助Spring的@Autowired注解 程序清单4.1 通过自动配置,将一个CompactDisc注入到CDPlayer之中 123456789101112public class CDPlayer implements MediaPlay&#123; private CompactDisc cd ; @Autowired public CDPlayer(CompactDisc cd )&#123; this.cd = cd ; &#125; public void play() &#123; cd.play(); &#125;&#125; @Autowired不仅可以在构造函数,还可以用在类的任何方法上 注意： 123456789@Autowired(required=false)public CDPlayer(CompactDisc cd)&#123; this.cd = cd ;&#125; // 如果没有匹配的bean,那么在应用上下文创建的时候,Spring会抛出一个异常。为了避免异常的出现，可以将@Autowired的required属性设置为false、// 将request属性设置为false时,Spring会尝试执行自动装配,但是如果没有匹配的bean的话,Spring将会让这个bean处于未装配的状态。如果代码没有进行null检查的话,这个处于未装配状态的属性有可能会出现NullPointerException @Inject注解来源于java依赖注入规范,该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowird之间有一个细微的差别,但是在大多数场合下,他们是可以相互替换的. 通过java代码装配bean 创建配置类 1234567891011@Configuration@ComponentScanpublic class CDplayerConfig &#123; @Bean public CompactDisc sgtPeppers()&#123; return new SgtPeppers(); &#125;&#125;// @Configuration表面这个类是一个配置类 声明简单的bean要在JavaConfig中声明bean,我们需要编写一个方法,这个方法会创建所需要类型的实例,然后给这个方法添加@Bean注解 12345@Beanpublic CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; 借助JavaConfig实现注入在JavaConfig中装配bean最简单方式就是引用创建bean的方法,例如,在下面就是一种声明CDPlayer的可行方案: 123456@Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(sgtPeppers());&#125; 通过XML装配bean 声明一个简单的 借助构造器注入在XML中声明DI时,会有很多种可选的配置方案和风格。具体到构造器注入,有两种基本的配置方案可供选择: 元素 使用Spring3.0所引入的c-命名空间 例子: 将声明了SgtPeppers bean，并实现了CompactDisc接口注入到CDPlayer。 1234567&lt;bean id=\"cdPlayer\" class=\"soundsystem.CDPlayer\"&gt; &lt;constructor-arg ref=\"compactDisc\" /&gt;&lt;/bean&gt;// 当Spring遇到这个&lt;bean&gt;元素时,它会创建一个CDPlayer实例。&lt;constructor-arg&gt;元素会告知Spring要将一个ID为compactDisc的bean引用传递到CDPlayer的构造器 在c-命名空间和模式声明之后, 123&lt;bean id=\"cdPlayer\" class=\"soundsystem.CDPlayer\"c:cd-ref=\"compactDics\" /&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sunshine23lin.github.io/categories/Spring/"}],"tags":[]},{"title":"springboot之国际化","slug":"springboot-3","date":"2019-08-13T07:05:49.000Z","updated":"2019-08-13T07:49:15.252Z","comments":true,"path":"2019/08/13/springboot-3/","link":"","permalink":"https://sunshine23lin.github.io/2019/08/13/springboot-3/","excerpt":"","text":"一、springboot之国际化编写国际化的步骤 编写配置文件 设置项目的配置 springboot自动配置好了管理国际化资源文件的组件（在配置文件修改） spring.messages.basename=i18n.login 去页面获取国际的值 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body class=\"text-center\"&gt;&lt;form class=\"form-signin\" action=\"dashboard.html\" th:action=\"@&#123;/user/login&#125;\" method=\"post\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;!--判断--&gt; &lt;p style=\"color: red\" &gt;&lt;/p&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" /&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='zh_CN')&#125;\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='en_US')&#125;\"&gt;English&lt;/a&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原来: 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 1234567891011@Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver()localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125; // 默认的就是根据请求头带来的区域信息获取Locale进行国际化 点击链接切换国际化1234567891011121314151617 public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if (!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://sunshine23lin.github.io/categories/SpringBoot/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"https://sunshine23lin.github.io/tags/Java后端/"}]},{"title":"Springboot\"配置文件\"","slug":"springboot-2","date":"2019-08-07T06:41:03.000Z","updated":"2019-08-08T09:54:20.078Z","comments":true,"path":"2019/08/07/springboot-2/","link":"","permalink":"https://sunshine23lin.github.io/2019/08/07/springboot-2/","excerpt":"","text":"一、配置文件SpringBoot使用一个全局的配置文件,配置文件名是固定的; application.properties application.yml 配置文件的作用: 修改SpringBoot自动配置的默认值;SpringBoot在底层都给我们自动配置好 YAML: 以数据为中心,比json、xml等更适合做配置文件YAML: 配置例子 server: port: 8081 XML: 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt; &lt;/server&gt; 1、YAML语法YAML语法： 基本语法K: (空格) V:表示一对键值对(空格必须有)以空格的缩进来控制层级关系;只要是左对齐的一列数据,都是同一个层级 server: port: 8081 path: /hello 值的写法K:v:字面直接来写字符串默认不用加上单引号或者双引号“”:双引号；不会转义字符串里面的特殊字符;特殊字符会作为本身想表示的意思‘’:单引号;会转义特殊字符,特殊字符最终只是一个普通的字符串数据 对象、Map(属性和值)(键值对) fridends: lastName: zhangsan age: 20 行内写法 friends: {lastName: zhangsan,age: 18} 2、 配置文件值注入 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2 : 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 person类 1234567891011121314151617/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * ** 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boos; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; list; private Dog dog; 3、配置文件站位符占位符获取之前配置的值,如果没有可以是用:指定默认值 123456789person.last‐name=张三$&#123;random.uuid&#125; person.age=$&#123;random.int&#125; person.birth=2017/12/15person.boss=false person.maps.k1=v1 person.maps.k2=14 person.lists=a,b,c person.dog.name=$&#123;person.hello:hello&#125;_dog person.dog.age=15 4、Profile 多Profile文件 我们在主配置文件编写的时候,文件名可以是application-{profile}.properties/yml默认使用application.properties的配置 yml支持多文档块方式1234567891011121314151617spring: profiles: active: dev---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: prod--- 5、激活指定profile 在配置文件中指定spring.profile.active=dev 命令行: java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； 虚拟机参数 -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Springboot的默认配置文件-file:./config/–file:./-classpath:/config/-classpath:/优先级由高到底,高优先级的配置会覆盖低优先级的配置SpringBoot会从这四个位置全部加载主配置文件;互补配置 spring.config.location来改变默认的配置文件位置项目打包好以后,我们可以使用命令行参数的形式,启动项目的时候来指定配置文件的新位置;指定配置文件和默认加载这些配置文件共同起作用形成互补配置 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、自动配置原理 自动配置原理:1) SpringBoot启动的时候加载主配置类,开启了自动配置功能@EnableAutoConfiguration2) @EnableAutoConfiguration作用: 利用EnableAutoConfiguationImportSelector给容器中导入一些组件 可以查看selectImports()方法的内容; List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 SpringFactoriesLoader.loadFactoryNames() 扫描所有jar包类路径下 META‐INF/spring.factories 把扫描到的这些文件的内容包装成properties对象 从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器 中 精髓: 1)、SpringBoot启动会加载大量的自动配置类2)、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类3)、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）4)、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这 些属性的值； 细节 @Conditional派生注解（Spring注解版原生的@Conditional作用）","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://sunshine23lin.github.io/categories/SpringBoot/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"https://sunshine23lin.github.io/tags/Java后端/"}]},{"title":"netty-\"Protobuf\"","slug":"netty-3","date":"2019-08-02T10:06:32.000Z","updated":"2019-08-07T03:27:18.862Z","comments":true,"path":"2019/08/02/netty-3/","link":"","permalink":"https://sunshine23lin.github.io/2019/08/02/netty-3/","excerpt":"","text":"一、protobuf简单入门 简介 它是一种轻便高效的数据格式,平台无关、语言无关、可扩展、可用于通讯协议和数据存储等领域 优点 平台无关，语言无关，可扩展 提供了友好的动态库，使用简单； 解析速度快，比对应的XML快约20-100倍； 序列化数据非常简洁、紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。 简单例子 pom内容 12345&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt;&lt;/dependency&gt; 编写Student.proto 12345678910111213141516syntax= &quot;proto2&quot;;//使用方式：gradle generateProto (不能再用以前那种方式，因为那个只会生成message，不会生成service)//这个就相当于 在 右边gradle的other中的插件generateProto，使用后生成的代码放在build/generated中//生成完代码记得拷贝到java目录中package com.protobuf.proto;option optimize_for = SPEED;//加快解析速度，详细可以去官网查加快解析速度，不写默认是这个option java_package=&quot;com.tongda.protobuf&quot;;option java_outer_classname=&quot;StudentInfo&quot;;message Student&#123; required string name=1; optional int32 id=2; optional string address=3;&#125; 执行命令 protoc.exe –java_out 测试类 1234567891011121314151617 import com.google.protobuf.InvalidProtocolBufferException;public class ProtoBufTest &#123; public static void main(String[] args) throws InvalidProtocolBufferException &#123; StudentInfo.Student student = StudentInfo.Student.newBuilder() .setName(\"张三\") .setId(12121) .setAddress(\"潮州\").build(); byte[] studnet2ByteArray = student.toByteArray(); StudentInfo.Student student1 = StudentInfo.Student.parseFrom(studnet2ByteArray); System.out.println(student1.getName()); System.out.println(student1.getAddress()); &#125;&#125;","categories":[{"name":"Netty","slug":"Netty","permalink":"https://sunshine23lin.github.io/categories/Netty/"}],"tags":[]},{"title":"socket初步认识","slug":"socket-1","date":"2019-08-02T06:51:57.000Z","updated":"2019-08-02T07:50:46.650Z","comments":true,"path":"2019/08/02/socket-1/","link":"","permalink":"https://sunshine23lin.github.io/2019/08/02/socket-1/","excerpt":"","text":"前言 网络基础两台计算如何进行通信 IP:端口 &lt;–&gt; IP:端口 TCP/IP协议 a.TCP/IP是世界上应用最为广泛的协议,是以TCP和IP为基础的不同层次上多个协议的集合也称为：TCP/IP协议族 或 TCP/IP协议栈TCP: Transmission Control Protocol 传输控制协议IP: Internet Protocol 互联网协议 TCP/IP模型 端口 a.用于区分不同应用程序b.端口号范围为065535,其中01023为系统所保留c.Ip地址和端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点,是TCP和UDP的基础。http:80 ftp:21 telnet:23 TCP详解 转载 https://blog.csdn.net/sinat_36629696/article/details/80740678 UPD协议 转载 https://blog.csdn.net/china_jeffery/article/details/78923428 一、Socket初步认识 什么是Socket编程 Socket是应用层与TCP/IP协议族通信的中间抽象层,它是一组接口。在设计模式中,Socket其实就是一个门面模式,它把复杂的TCP/IP协议族隐藏在Socket接口后面,对于用户来说,一组简单的接口就是全部让Socket去组织数据,以符合指定的协议。例子：你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理 2.","categories":[{"name":"Scoket","slug":"Scoket","permalink":"https://sunshine23lin.github.io/categories/Scoket/"}],"tags":[]},{"title":"netty-\"Hello World\"","slug":"netty-2","date":"2019-08-02T05:29:08.000Z","updated":"2019-08-02T05:58:04.583Z","comments":true,"path":"2019/08/02/netty-2/","link":"","permalink":"https://sunshine23lin.github.io/2019/08/02/netty-2/","excerpt":"","text":"前期pom文件 12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.8.Final&lt;/version&gt;&lt;/dependency&gt; TestServer 1234567891011121314151617181920212223242526272829public class TestServer&#123; /** * 事件循环组，就是死循环 */ //仅仅接受连接，转给workerGroup，自己不做处理 EventLoopGroup bossGroup=new NioEventLoopGroup(); //真正处理 EventLoopGroup workerGroup=new NioEventLoopGroup(); try &#123; //很轻松的启动服务端代码 ServerBootstrap serverBootstrap=new ServerBootstrap(); //childHandler子处理器,传入一个初始化器参数TestServerInitializer（这里是自定义） //TestServerInitializer在channel被注册时，就会创建调用 serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class). childHandler(new TestServerInitializer()); //绑定一个端口并且同步，生成一个ChannelFuture对象 ChannelFuture channelFuture=serverBootstrap.bind(8899).sync(); //对关闭的监听 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; //循环组优雅关闭 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; &#125; TestServerInitializer 12345678910111213141516 public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; //这是一个回调的方法，在channel被注册时被调用 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //一个管道，里面有很多ChannelHandler，这些就像拦截器，可以做很多事 ChannelPipeline pipeline=ch.pipeline(); //增加一个处理器，neet提供的.名字默认会给，但还是自己写一个比较好 /** * 注意这些new的对象都是多例的，每次new出来新的对象,因为每个连接的都是不同的用户 */ //HttpServerCodec完成http编解码，可查源码 pipeline.addLast(\"httpServerCodec\",new HttpServerCodec()); //增加一个自己定义的处理器hander pipeline.addLast(\"testHttpServerHandler\",new TestHttpServerHandler()); &#125;&#125; TestHttpServerHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 继承InboundHandler类,代表处理进入的请求,还有OutboundHandler */public class TestHttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; // channelRead0读取客户请求,并返回响应方法 protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123; // 判断这个是不是httpRequest// if (msg instanceof HttpRequest) &#123; // 判断url是否请求了favicon.ico System.out.println(msg.getClass()); AttributeKey&lt;String&gt; ATTRIBUTE_KEY_VIN = AttributeKey.valueOf(\"VIN\"); ctx.channel().attr(ATTRIBUTE_KEY_VIN).set(\"aaavv00\"); System.out.println(\"VIM:\"+ctx.channel().attr(ATTRIBUTE_KEY_VIN).get()); System.out.println(ctx.channel().remoteAddress()); HttpRequest httpRequest= (HttpRequest) msg; URI uri=new URI(httpRequest.uri()); // 判断url是否请求了favicon.ico if (\"/favicon.ico\".equals(uri.getPath()))&#123; System.out.println(\"请求了favicon.ico\"); return; &#125; /** * 上面这段代码是验证如果用浏览器访问 * 浏览器发起了两次请求,一个是发起的端口,第二是请求favicon.ico图标 */ // 代表响应返回的数据 ByteBuf context = Unpooled.copiedBuffer(\"Hello World\", CharsetUtil.UTF_8); //构造一个http响应,HttpVersion.HTTP_1_1:采用http1.1协议，HttpResponseStatus.OK：状态码200 FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, context); response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"test/plain\"); response.headers().set(HttpHeaderNames.CONTENT_LENGTH, context.readableBytes()); // 如果只是调用write方法,他仅仅在存在缓冲区,并不会返回客户端 // ctx =null; ctx.writeAndFlush(response);// &#125; &#125; /** * 添加handler * @param ctx * @throws Exception */ @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(\"handlerAdded\"); super.handlerAdded(ctx); &#125; /** * 管道被注册 * @param ctx * @throws Exception */ @Override public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(\"channelRegistered\"); super.channelRegistered(ctx); &#125; /** * 当建立连接之后调用此方法 * @param ctx * @throws Exception */ public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(\"channelActive\"); super.channelActive(ctx); &#125; /** * 断开连接调用此方法 * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(\"channelInactive\"); super.channelInactive(ctx); &#125; @Override public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(\"channelUnregistered\"); super.channelUnregistered(ctx); &#125; /** * 当发送异常的时候调用此方法 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.channelActive(ctx); &#125;&#125;","categories":[{"name":"Netty","slug":"Netty","permalink":"https://sunshine23lin.github.io/categories/Netty/"}],"tags":[]},{"title":"netty初步认识","slug":"netty-1","date":"2019-07-04T08:27:08.000Z","updated":"2019-08-02T03:51:42.538Z","comments":true,"path":"2019/07/04/netty-1/","link":"","permalink":"https://sunshine23lin.github.io/2019/07/04/netty-1/","excerpt":"","text":"一、netty的简介 什么是Netty Netty是一个利用java的高级网络的能力,隐藏其背后的复杂性而提供一个易于使用的API的客户端/服务器框架。 Netty构成部分Channel Channel是NIO基本结构,他代表一个用于连接到实体如硬件设备、文件、网络套接字或程序组件,能够执行一个或者多个不同的I/O操作的开发连接。把Channel想象成一个可以”打开”或者”关闭”,”连接”或”断开”和作为传入和传出数据的运输。 Callback (回调) callback (回调)是一个简单的方法,提供给另一种方法作为引用,这样后者就可以在某个合适的 时间调用前者。这种技术被广泛使用在各种编程的情况下,最常见的方法之一通知给其他人操 作已完成。 Future Future 提供了另外一种通知应用操作已经完成的方式。这个对象作为一个异步操作结果的占 位符,它将在将来的某个时候完成并提供结果。 Event和Handler Netty使用不同的事件来通知我们更改的状态和操作的状态。这使我们能够根据发送的事件触发适当的行为。这些行为可能包括: 日志 数据转换 流控制 应用程序逻辑 由于Netty是一个网络框架,事件很清晰的跟入站或或出站数据流相关。因为一些事件可能触发传入的数据或状态的变化包括： 活动或者非活动连接 数据的读取 用户事件 错误 出站事件是由于在未来操作将触发一个动作。这些包括: 打开或关闭一个连接到远程 写或冲刷数据到socket","categories":[{"name":"Netty","slug":"Netty","permalink":"https://sunshine23lin.github.io/categories/Netty/"}],"tags":[]},{"title":"SpringBoot入门","slug":"SpringBoot入门","date":"2019-06-14T02:06:33.000Z","updated":"2019-08-02T06:56:58.147Z","comments":true,"path":"2019/06/14/SpringBoot入门/","link":"","permalink":"https://sunshine23lin.github.io/2019/06/14/SpringBoot入门/","excerpt":"","text":"#一、SpringBoot第一个入门案例 创建项目 菜单 -&gt; New -&gt; Project -&gt; Spring Initializr 然后点 Next 2.项目参数 输入如图所示的两个地方的参数，其他参数不用修改，然后Next 3.选择Web模块 接着左边选择 Web, 右边只勾选 Web 即可，然后点击Next 4.SpringbootApplication.java 项目创建好之后，就自带一个SpringbootApplication, 其被@SpringBootApplication 所标记，表示这个是一个Springboot 应用 5.HelloController.java 新建包 com.how2java.springboot.web， 然后在其下新建类HelloController.这个类就是Spring MVC里的一个普通的控制器。@RestController 是spring4里的新注解，是@ResponseBody和@Controller的缩写。 12345678910111213package com.how2java.springboot.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello() &#123; return \"Hello Spring Boot!\"; &#125; &#125; 6.运行并测试 接下来就运行 SpringbootApplication.java， 然后访问地址http://127.0.0.1:8080/hello","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://sunshine23lin.github.io/categories/SpringBoot/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"https://sunshine23lin.github.io/tags/Java后端/"}]},{"title":"spring依赖注入","slug":"spring依赖注入","date":"2019-06-10T00:58:30.000Z","updated":"2019-06-10T05:45:34.520Z","comments":true,"path":"2019/06/10/spring依赖注入/","link":"","permalink":"https://sunshine23lin.github.io/2019/06/10/spring依赖注入/","excerpt":"","text":"一、Spring的依赖注入概述 注入的方式:只有3种 第一种方式:通过构造函数第二种方法:通过set方法 注入内容: 第一类:基本类型和String类型第二类:其它的bean第三类:复杂类型(集合类型) 二、依赖注入方式-xml 构造函数 12345678910111213141516171819 &lt;!-- 涉及的标签: constructor-arg 该标签是写在bean标签内部发子标 标签的属性: type:指定要注入的参数在构造函数中类型 index:指定要注入的参数在构造函数的索引位置 name: 指定参数在构造函数的中的名称 value:指定注入的数据内容,他只能指定基本类型数据和String类型数据 ref:指定其他bean类型数据。写的其它bean的id --&gt; &lt;bean id=\"accountService\" class=\"com.mydata.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"莫斯特\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" value=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Data\"&gt;&lt;/bean&gt; Set方法注入 1234567891011121314 &lt;!-- 涉及的标签:property 标签的属性: name:指定的是set方法的名称。匹配的是类中set后面的部分 value:指定注入的数据内容 ref: 其它bean类型 &lt;bean id=\"accountService2\" class=\"com.mydata.service.impl.AccountServiceImpl\"&gt;&lt;property name=\"name\" value=\"莫斯特\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt;&lt;property name=\"birthday\" value=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt; --&gt; 三、依赖注入方法-注解12345678910111213141516171819202122232425262728293031323334353637&lt;!--用于创建对象@Componet: 作用:就相当于spring的xml配置文件中写了一个bean标签 属性: value:用于指定bean的id。当不写时,默认值当前类名,首字母改小写 由此注解衍生的三个注解: @Controller:一般用于表现层 @Service：一般用于业务层 @Repository:一般用于持久层 他们的作用以及属性和@Compoent的作用是一模一一样。spring框架为我们提供更明确的语义来指定不同层 @Autowired 作用:自动按照类型注入。只要容器中有唯一的类型匹配,则可以直接注入成功。 细节:当使用此注解注入时,set方法就可以省略了 @Qualifier 作用:在自动按照类型注入的基础上,再按照bean的id注入。在给类成员注入时,他不能够独立使用。 属性: value:用于指定bean的id @Resource 作用:直接按照bean的id注入 属性: name:用于指定bean的id 以上3个注解,都只能用于注入其他bean类型,而不能注入基本类型各String @value 作用:用于注入基本类型和String类型的数据。 属性: value:用于指定要注入的数据。它支持使用Spring的el表达式。 spring的el表达式写法: $&#123;表达式&#125; &lt;context:property-placeholder location=\"\" /&gt; --&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sunshine23lin.github.io/categories/Spring/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"https://sunshine23lin.github.io/tags/Java后端/"}]},{"title":"bean对象","slug":"bean对象","date":"2019-06-06T09:17:08.000Z","updated":"2019-06-10T00:40:10.504Z","comments":true,"path":"2019/06/06/bean对象/","link":"","permalink":"https://sunshine23lin.github.io/2019/06/06/bean对象/","excerpt":"","text":"一、bean对象的三种创建方式 通过调用构造函数来创建bean对象(常用) 在默认情况下,当我们在spring的配置文件中写了一个bean标签,并提供了class属性,spring会调用默认构造函数创建对象,如果没有默认构造函数，则对象创建失败 12345public class HelloService &#123; public void hello()&#123; System.out.println(\"hello spring\"); &#125;&#125; 通过静态工厂创建bean对象 工厂类中提供了一个静态方法,可以返回要用到bean对象 123456789ublic class StaticBeanFactory &#123; /** * 模拟一个获取bean对象的方法 */ public static HelloService getBean()&#123; return new HelloService(); &#125;&#125; 3.通过实例创建bean对象 123456public class InstanceBeanFactory &#123; public HelloService getBean()&#123; return new HelloService(); &#125;&#125; spring.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- xmlns 即 xml namespace xml 使用的命名空间 xmlns:xsi 即 xml schema instance xml 遵守的具体规范 xsi:schemaLocation 本文档 xml 遵守的规范 官方指定 --&gt; &lt;!-- 属性： id:对象的唯一标识 class:要创建对象的全限定类名 factory-method:指定创建bean对象的方法,该方法可以是静态的,也可以部署、 factory-bean : 指定创建bean对象的工厂bean的id bean对象的三种创建方式 第一种:通过调用构造函数来创建bean对象 常用 在默认情况下,当我们在spring的配置文件中写了一个Bean标签,并提供了class属性,spring就会调用默认构造函数创建对象 如果没有默认构造函数,则对象创建失败 第二种：通过静态工厂创建bean对象,工厂类中提供一个静态方法,可以返回要用到bean对象 --&gt; &lt;!-- 默认构造函数 --&gt; &lt;bean id=\"helloService\" class=\"com.myweb.spring.HelloService\"&gt;&lt;/bean&gt; &lt;!--静态工厂创建 --&gt; &lt;bean id=\"staticBeanFactory\" class=\"com.myweb.spring.StaticBeanFactory\" factory-method=\"getBean\"&gt;&lt;/bean&gt; &lt;!-- 实例工厂创建--&gt; &lt;bean id = \"instanceBeanFactory\" class=\"com.myweb.spring.InstanceBeanFactory\"&gt;&lt;/bean&gt; &lt;bean id=\"instanceHelloBeanFactory\" factory-bean=\"instanceBeanFactory\" factory-method=\"getBean\" &gt;&lt;/bean&gt;&lt;/beans&gt; 二、bean对象的作用范围 配置的属性:bean标签的scope属性属性的取值: singleton:单例的。 默认 prototype:多例 request:请求范围 session:会话范围 global-session:全局会话 范围 三、bean对象的生命周期","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sunshine23lin.github.io/categories/Spring/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"https://sunshine23lin.github.io/tags/Java后端/"}]},{"title":"IntelliJ IDEA创建Spring Maven 项目 - HelloWorld","slug":"初步搭建spring","date":"2019-06-06T03:11:25.000Z","updated":"2019-06-06T09:36:49.341Z","comments":true,"path":"2019/06/06/初步搭建spring/","link":"","permalink":"https://sunshine23lin.github.io/2019/06/06/初步搭建spring/","excerpt":"","text":"一、创建新项目 创建一个新项目，Maven - Create from archetype，选中maven-archetype-webapp这个archetype 输入GroupId和ArtifactId 输入项目名称并选择项目存放的路径 二、引入Spring 打开pom.xml，引入Spring 123456789101112131415161718192021222324252627&lt;!-- spring框架核心--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写 bean 1234567package com.shsxt.service;public class HelloService &#123; public void hello()&#123; System.out.println(&quot;hello spring&quot;); &#125;&#125; spring 配置文件的编写在 src 下新建 xml 文件，并拷贝官网文档提供的模板内容到 xml 中，配置bean 到 xml 中,把对应 bean 纳入到 spring 容器来管理 12345678910111213 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!--xmlns 即 xml namespace xml 使用的命名空间xmlns:xsi 即 xml schema instance xml 遵守的具体规范xsi:schemaLocation 本文档 xml 遵守的规范 官方指定--&gt;&lt;bean id=\"helloService\" class=\"com.shsxt.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; 验证 spring 框架环境是否搭建成功 123456789101112131415161718192021222324package com.shsxt.service;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloServiceTest &#123; @Test public void test1() throws Exception &#123; /** * 1.加载Spring的配置文件 * 2.取出Bean容器中的实例 * 3.调用bean方法 */ // 1.加载Spring的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); // 2.取出Bean容器中的实例 HelloService helloService = (HelloService) context.getBean(&quot;helloService&quot;); // 3.调用bean方法 helloService.hello(); &#125;&#125; 验证结果","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sunshine23lin.github.io/categories/Spring/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"https://sunshine23lin.github.io/tags/Java后端/"}]}]}